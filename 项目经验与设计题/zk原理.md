# ZAB协议（Atomic Broadcast 原子广播协议）
- 作为其数据一致性核心的算法。，是
    - 1 崩溃可恢复的：当服务框架启动或者Leader崩溃，网络中断或者重启，我们会选举新的Leader，
    当超过半数follower与Leader数据同步完成之后（保证数据状态一致）。此时恢复完成，退出恢复模式。
    
    - 2 原子消息广播算法
        - 核心原理（数据同步机制）：leader将我们应用服务器的请求转换成一个事务Proposal，并且广播到集群中所有的Follower当中
    只要有超过半数的Follower进行了正确的反馈之后，Leader会再次向所有的Follower分发Commit消息，要求
    其将前一个事务提交。
        - 基于TCP协议，可以保证消息发送与接收的顺序性。
        - 事务ID：ZXID，单调递增的唯一ID，在Leader广播事务之前会进行创建。
            - 64位的数字
            - 低32位，应用服务器没产生一次事务请求，就+1
            - 高32位代表Leader的周期编号，每选举一个Leader，会从其中找出其本地日志中最大的ZXID，取高32位然后就+1；重新选举之后，低32位清零
                - 保证了当前Leader不会以之前的Leader的ZXID，去提交与之前Leader ZXID 不同的事务请求的。
                - 如 Leader1提交了 ZXID1， 此时Leader1挂了，选举出Leader2，Leader2也不会使用ZXID1去提交新的事务
 
- 选举算法：Leader不可用，从其他Follower选举出 ZXID最大的机器作为Leader，他已经具有所有最新的事务提案。
    
```
# dubbo注册中心的地址
dubbo.registry.address=zookeeper://zk6.prod.souche:2181?backup=zk7.prod.souche:2181,zk8.prod.souche:2181,zk1.prod.souche:2181,zk4.prod.souche:2181,zk5.prod.souche:2181

```

# zookeeper分布式锁
- 独占锁：
    - 创建锁：在zk上创建一个临时节点/exclusive_lock/lock,会保证同时只有一个一台服务器能够创建成功
        - 其他没有获取的服务器会就需要到/exclusive_lock上注册一个子节点变更的Watcher（时间通知机制）。
    - 释放锁：
        - 1 执行完正常业务之后 
        - 2 创建临时节点的服务器发生宕机
        
- 共享锁
    - 创建锁：只能读不能写、写完只能在共享锁结束。 多个客户端请求共享锁都会创建一个**节点序号**
        - 读请求：先来的序列号小，如果前面序列号都是读请求，那么同步执行读操作
            - 如果前面序号有写请求，则需要等待
        - 写请求：如果自己是最小的序列号，则执行
        
    
# 应用场景
## 数据发布与订阅
- zk采用的时候推拉结合的方式
    - 应用服务器想zk注册自己需要关注的节点，一旦节点数据发生变更，zk会主动的向应用服务器发送Watcher时间通知
    应用服务器接受到这个消息之后，主动向zk拉取对应的最新的配置
    - 配置可以是
        -机器列表，运行时开关配置，数据库配置信息等
## 负载均衡
- 当服务器宕机，zookeeper因为没有检测到心跳，自动把该节点移除，并通知其他服务器，其他服务器得知该机器已宕机，在分配连接时，不会分配到这台机器上，这点也是标题说的在负载均衡中用到zookeeper的原因

## 命名服务
- 使用分布式全局唯一ID的分配机制，如 type-job-0000000003，可以来唯一标识一个API接口

## 分布式协调/通知
- zk中特有的Watcher注册与异步通知机制，能够很好的实现分布式系统下的不同机器的，不同系统的协调与通知
    - 实现对数据变更 的**实时处理**
    - 实现的方式：所有的应用服务器都会在zk上同一个数据节点注册一个监听器Watcher，
    如果数据发生变动之后，zk会主动告知所有监听的服务器有数据变更，他们就会主动拉取这种变更。
    
## 任务热备份（Mysql），还是作为通知的角色

-  Running机器为主机器，Standby为子机器 ，所有机器都会在mysql上创建一个临时节点，按顺序号id来排列，
server1 server2....等，  id最小的为Running运行主机。
- 所有Standby机器都需要注册一个"子节点列表变更"的Watcher监听，如果Running机器宕机与zk断开连接，
其他Standby收到这个通知后，会进入下一轮Running机器选举。
- 总结：还是 "小序号优先"的选举规则，主机宕机，会选取最小顺序号的机器来代替主机。
    - 至少使用两台机器

## 冷备份
- 采用多进程扫描的方式，而不是多机器实时进行数据备份。降低了任务的协调的实时性，但是节省了机器资源。

## 一种通用的分布式系统机器间的通信方式

- 心跳检测
    - 基于zk的**临时节点**的特性，可以让不同的机器在zk的一个指定节点下创建临时节点，不同机器之间通过这个临时节点来判断
    对应的机器是否存活。
    - 好处：被检测系统和检测系统不需要直接关联，大大减少了系统的耦合。
- 工作汇报进度：都是运用临时节点的特性。
- 系统调度

- 总结：zk实现分布式系统之间的通信
    - 节省大量底层网络通信的协议设计上的重复工作
    - 主要是减低系统之间的耦合程度， 非常灵活的实现异构系统之间灵活的通信。

- 集群管理：也就是监控集群中所有机器的删减，数据的变更，对所有机器进行同步
    - 还是使用临时节点和Watcher监控通知的机制。
    - 所有机器创建临时节点在zk上，如果某个机器数据变更了或者是zk上的节点列表发生变更，通过Watcher监控会通知到所有的机器数据的变更。
    - 在zk上创建临时节点，一旦server与zk之间会话失效，临时节点也会自动删除。


# Master选举
- 还是最先创建临时节点的机器为master，其他机器创建一个Watcher监听，如果Master挂了，重新进行Master选举（ZXID）

#分布式队列
- FIFO：
    - 1 所有Server在zk上创建一个临时节点，按序列号的方式排列
    - 2 每个机器在向比自己序列号小的最后一个节点注册一个Watcher监听，收到Watcher通知后，开始执行。
- Barrier：分布式屏障
    - 设置/queue_barrier节点 的值 n = 某个数，如10，当队列的数量达到10的时候一并的全部执行。    







- zk原
- mysql什么时候不会用到索引
- redis 持久化方式
- spring的原理理
    - IOC AOP