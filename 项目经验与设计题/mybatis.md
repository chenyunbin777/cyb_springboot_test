# Mybatis一级缓存 二级缓存

- 1一级缓存是SqlSession级别的缓存。在操作数据库时需要构造SqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的SqlSession之间的缓存数据区域（HashMap）是互不影响的。
在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，MyBatis提供了一级缓存的方案优化这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。
Mybatis中，一级缓存默认是开启的。
一级缓存又称为查询缓存。

- org.apache.ibatis.session.Configuration.cacheRefMap 保存一级缓存的位置

- **一次sql查询之后会缓存，再次更新会删除缓存，之后在查询，在去缓存**
- SqlSession中执行了任何一个更新操作，例如：update、delete、insert ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用；

- 2 二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。
当开启缓存后，数据的查询执行的流程就是 二级缓存 -> 一级缓存 -> 数据库。
    - 过期时间：flushInterval = "1000" 
```
一二级缓存同时开启的情况下，数据的查询顺序是 二级缓存 -> 一级缓存 -> 数据库。一级缓存比较简单，而二级缓存可以设置更多的属性，只需要在 mapper 的 xml 文件中的 <cache /> 配置即可，具体如下：
<cache
        type = "org.mybatis.caches.ehcache.LoggingEhcache"  //指定使用的缓存类，mybatis默认使用HashMap进行缓存,可以指定第三方缓存
        eviction = "LRU"  //默认是 LRU 淘汰缓存的算法，有如下几种：
                          //1.LRU – 最近最少使用的:移除最长时间不被使用的对象。
                          //2.FIFO – 先进先出:按对象进入缓存的顺序来移除它们。 
                          //3.SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。 
                          //4.WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象
        flushInterval = "1000"  //清空缓存的时间间隔，单位毫秒，可以被设置为任意的正整数。  默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新。
        size = "100"      //缓存对象的个数，任意正整数，默认值是1024。
       readOnly  = "true"  //缓存是否只读，提高读取效率
       blocking = "true"   //是否使用阻塞缓存，默认为false，当指定为true时将采用BlockingCache进行封装，blocking，
                           //阻塞的意思，使用BlockingCache会在查询缓存时锁住对应的Key，如果缓存命中了则会释放对应的锁，
                           //否则会在查询数据库以后再释放锁这样可以阻止并发情况下多个线程同时查询数据，详情可参考BlockingCache的源码。 
/>

```




- 总结： MyBatis的二级缓存相对于一级缓存来说，实现了SqlSession之间缓存数据的共享，同时粒度更加的细，能够到namespace级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。
  MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。
  在分布式环境下，**由于默认的MyBatis Cache实现都是基于本地的**，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。
  
- 一级缓存针对某一条sql的查询，而二级缓存针对 本机的所有sql的缓存。 分布式情况下有可能会产生脏读情况。
  
  
- 