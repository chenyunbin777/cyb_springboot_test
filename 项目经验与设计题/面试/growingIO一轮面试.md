# Mysql
- select * from table where b = 1; b没有加索引，查询数据的流程是怎么样
- explain参数：
    - select_type
        - SIMPLE(简单SELECT，不使用UNION或子查询等)
    - type
        - ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好）
        - ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行
        - index: Full Index Scan，index与ALL区别为
            - index类型只遍历索引树
        - **range:只检索给定范围的行，使用一个索引来选择行**
        - ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
        - eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件
        - const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，
            - system是const类型的特例，当查询的表只有一行的情况下，使用system
        - NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。
           
    - rows:扫描行数特别多，怎么进行优化？
    - 如果发现查询需要大量的数据但值返回少数行，那么通常可以尝试下面的技巧去优化它：
        - https://www.cnblogs.com/beiluowuzheng/p/10119834.html
        - 1 使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无需回表获取对应的行就可以返回结果了。
        - 2 **改变库表结构。例如使用单独的汇总表。**
        - 3 重写这个查询，让MySQL优化器能够以更优化的方式执行这个查询。
- 慢查询
    - 慢查询的默认时间，多长时间会报错慢查询
    - MySQL是否在扫描额外的记录
      在确定查询只返回所需要的列后，接下来便是看看查询是否扫描过多的数据。对于MySQL，最简单的衡量查询开销的三个指标如下：
          - 1 响应时间。
          - 2 扫描的行数。
          - 3 返回的行数。
          - 没有哪个指标能够完美地衡量查询的开销，但它们大致反映了MySQL在内部执行查询时需要多少数据，并可以推算出查询运行的时间。这三个指标都会记录到MySQL的慢日志中，所以检查慢日志记录是找出扫描行数过多的查询的好办法。         
    - MySQL不会告诉我们生成结果实际上需要扫描多数行数据，而只会告诉我们生成结果时一共扫描了多数行数据。
- bree 与 bree+ 数的区别
https://blog.csdn.net/pangchengyong0724/article/details/76168576
- b 树：B树里面，每个结点有这样的特点：不论是叶结点还是非叶结点，都含有Key和一个指向数据的指针。
这样，一旦找到某个结点以后，就可以根据指针找到对应的磁盘地址。
    - 但是，这也带来了另外的问题，就是每一个数据的指针会带来额外的内存占用，从而减少放入内存的结点数。
       
- b+ tree：b==balance，因为B+树是从最早的平衡二叉树演化而来的。
    - 在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息（保存下一层节点的指针），
    这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。
    - b+树的叶子节点是一个单链表会串行的连接起来。可以通过单链表来顺序找到对应的数据

- 不同之处： b树每一个节点对应的一个数据，而b+树只有叶子节点保存数据，非叶子节点只保存的是对应的指针。   

# inndb锁
- 例如：id： 1 3 5 7 10 21 22
- 隔离级别为：可重复读
    - 行锁防止别的事务修改或删除，GAP锁防止别的事务新增，
    行锁和GAP锁结合形成的的Next-Key锁共同解决了RR级别在写数据时的不可重复读的问题。
- 1 next-key lock（临键锁）
     - select * from table where id > 2 and id < 5
     - 左开右闭  (]  id>i and i<=5 的范围的所有行都会被锁定
     

- 2 间隙锁：
    - begin select * from table where id > 10 and id < 20 for update  commit 不会查到任何记录
        - 那么这时就会在id：10~20之间加一个锁 ，如果你要插入这个范围的数据，就不成功，必须等前一个事务提交之后才可以。
    - begin select * from table where id = 15  commit
        -  id:10~21 都会被加锁
        
    - 若查询列上没有索引且不是主键，那么间隙锁会为整张表上锁
    
    
    
- 4 共享锁：可读，不可写

- 不可重复读：共享锁解决；幻读：临键锁解决；脏读：排它锁。


# Redis
## Redis分布式锁的使用？zk分布式锁之间有什么区别？
- SETEX KEY_NAME TIMEOUT VALUE：指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值。 
Redis缓存的使用
    - 保存对象使用hash
    - sorted set：内部结构：跳表，排行榜



线程池优化：阻塞队列需要设置对应的大小
    - 拒绝策略的使用
    - 阻塞队列的使用
        - 直接抛异常
        - 不抛异常，不处理
        - 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
        - 使用当前线程执行任务

ArrayList为什么插入比较慢？ 扩容会进行复制resize为 1.5倍，将老数组数据复制到新数组中、
- 在扩容的时候，首先将原元素数组的长度增大1.5倍（oldCapacity + (oldCapacity >> 1)），然后对扩容后的容量与minCapacity进行比较：① 新容量小于minCapacity，则将新容量设为minCapacity；②新容量大于minCapacity，则指定新容量。最后将旧数组拷贝到扩容后的新数组中。
CAS原理 Compare and sweep 比较和替换数据：操作系统级别
- sun.misc.Unsafe 底层的这个类实现的。Unsafe 类是个跟底层硬件CPU指令通讯的复制工具类
- CAS 被认为是一种乐观锁

跳表的原理： 1-100  ，1和100每一层都会存在


为什么年轻代使用复制算法？ 因为不会产生内存碎片
为什么老年代不使用复制算法？ 内存利用率太低，并且老年代对象存活的时间都是比较久的？

synchronized 锁升级过程，锁实在对象头中加入的？


# Mybatis
- 一级缓存和二级缓存
    - mybatis.configuration.cache-enabled=true //开启二级缓存
    - mybatis.configuration.local-cache-scope=session  //一级缓存作用域
- 二级缓存
```
一二级缓存同时开启的情况下，数据的查询顺序是 二级缓存 -> 一级缓存 -> 数据库。一级缓存比较简单，而二级缓存可以设置更多的属性，只需要在 mapper 的 xml 文件中的 <cache /> 配置即可，具体如下：
<cache
        type = "org.mybatis.caches.ehcache.LoggingEhcache"  //指定使用的缓存类，mybatis默认使用HashMap进行缓存,可以指定第三方缓存
        eviction = "LRU"  //默认是 LRU 淘汰缓存的算法，有如下几种：
                          //1.LRU – 最近最少使用的:移除最长时间不被使用的对象。
                          //2.FIFO – 先进先出:按对象进入缓存的顺序来移除它们。 
                          //3.SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。 
                          //4.WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象
        flushInterval = "1000"  //清空缓存的时间间隔，单位毫秒，可以被设置为任意的正整数。  默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新。
        size = "100"      //缓存对象的个数，任意正整数，默认值是1024。
       readOnly  = "true"  //缓存是否只读，提高读取效率
       blocking = "true"   //是否使用阻塞缓存，默认为false，当指定为true时将采用BlockingCache进行封装，blocking，
                           //阻塞的意思，使用BlockingCache会在查询缓存时锁住对应的Key，如果缓存命中了则会释放对应的锁，
                           //否则会在查询数据库以后再释放锁这样可以阻止并发情况下多个线程同时查询数据，详情可参考BlockingCache的源码。 
/>

```