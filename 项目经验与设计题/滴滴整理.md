系统架构
整体架构
模块设计
数据流转（离线特征，实时特征，离线训练，实时推断）
监控指标（离线监控，服务监控，模型性能监控，业务指标监控）
业务侧交互方式
简历项目
项目背景
收益预期
实际工作，难点挑战
项目成果，评估方法
总结思考，反思或优化空间
编程练习
非平衡二叉树，层次遍历节点值
给定两个有序整型数组，计算中位数，并给出时间复杂度
给定一个整形数组，请找出所有三项相加和为0的数字组合
文本最小编辑距离：两个字符串，计算出str1转换成str2所使用的最小操作数，只能进行如下三种操作，插入一个字符，删除一个字符，替换一个字符
K-means实现
深度优先遍历/广度优先遍历二叉树




# 逻辑推理篇
- 有一个牢房，有3个犯人关在其中。因为玻璃很厚，所以3个人只能互相看见，不能听到 对方说话的声音。” 有一天，国王想了一个办法，
给他们每个人头上都戴了一顶帽子，只叫他们知道帽子的颜色不是白的就是黑的，不叫他们知道自己所戴帽子的是什么颜色的。在这种情况 下，
国王宣布两条如下： 1．谁能看到其他两个犯人戴的都是白帽子，就可以释放谁； 2．谁知道自己戴的是黑帽子，就释放谁。 其实，
国王给他们戴的都是黑帽子。他们因为被绑，看不见自己罢了。于是他们3个人互相盯着不说话。可是不久，心眼灵的A用推理的方法，
认定自己戴的是黑帽子。您想 ，他是怎样推断的?
 
- 答案
其中一人，看到两人都是黑的，就会假设，若自己是白的帽子，那另外两个人中的一个（假设B）就能判断出自己带了黑帽子，
因为如果不是  第三个人就看到了两顶白帽子而会被释放（而他并没说自己看到了两顶白帽），由此第一个人可以推出自己带了黑帽子


# sql优化
- 操作系统和硬件

- 数据库本身
	- innodb_buffer_pool_size配置75%

- 业务应用：sql优化，索引优化，慢查询优化，垂直水平拆分

- 索引原理和b+树存储结构

- ACID：事务具有4个特征
	 一致性（事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。） 
	 隔离性（事务之间的操作是隔离的），
	 持久性（一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。--即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态）
	 原子性（事务操作是原子的，要不不做要不全做）
- 事务的隔离级别
	- 未提交读（事务A事务内执行修改操作，事务B可以看到A的修改（脏读））
	- 提交读（事务A提交之后，事务B事务内才可以看到A的修改（不可重复读））
	- 可重复读（事务A内读取的数据一直都是一样的，不会出现不用的情况（幻读：无法避免 “间隙锁”之外插入的数据））
	- 串行化（一切执行都串行按顺序执行，完全遵循ACID）


# TCP，网络
## 一 如何解决网络拥堵：
为了进行拥塞控制，TCP发送方要维持一个“拥塞窗口”的状态变量，大小取决于网路的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口 和 接收方的接收窗口取最小的一个
	- 拥塞窗口：Congestion Window ，简称：cwnd
	- 1 慢开始（slow - start）：探测，窗口逐渐增大，cwnd初始为1，没经过一个轮次的传播，cwnd加倍。
	- 2 堵塞避免（congestion avoidance）：也是cwnd缓慢增大，没经过一个往返时间RTT 就把发送方的cwnd+1
	- 3 快重传（fast retransmit），快恢复（fast recovery）：可以快的恢复丢失的数据包，如果接受端收到了一个不按顺序的数据段，他会给发送端发送一个重复确认ACk。
	如果接收端连续发送了3个ACK的话说明有数据段丢失了，并立即重传这些丢失的数据，并且快速的恢复数据。

## 二 如何保证可靠传输
- 1 应用数据被分割成TCP认为最合适的发送的数据块
- 2 TCP给发送的每一个包进行编号ID，接收端对数据包进行排序，把有序数据传输给应用层
- 3 校验和
	- 目的是检测数据在传输中的任何变化。如何收到的检验和由差错，TCP将丢弃这个报文段和不确认收到此报文段。
- 4 流量控制:TCP使用滑动窗口实现流量控制，也就是滑动窗口。
- 5 拥塞控制:当网络拥塞时，减少数据的发送
- 6 停止等待协议:为了实现可靠传输，他的基本原理就是每发送完一个分组就停止发送，等待对方确认接收之后在发送下一个分组。
- 7 超时重传:发送端等待接收端确认，如果没有ACK回传，那么就会重发这个报文段。

## 三 TCP TimeWait怎么产生的？有什么危害？
- 1 TimeWait怎么产生的：在TCP四次挥手过程中，客户端最后接收到server的FIN关闭连接消息之后，会发送ACK确认消息；但是客户端不相信网络，server有可能接受不到这个ACK消息，那么他会等待2MSL(最大报文段生存时间，默认30s一个)才会关闭连接状态。
- 2 有什么危害：TimeWait太多可能产生2类报错，TimeWait溢出（一个TIME_WAIT占用4k大小）或者是无法新建连接的（端口号耗尽） ，
		server端产生，则可能引起雪崩，要避免server主动关闭连接。
		
# TIME_WAIT过多危害
网络情况不好时，如果主动方无TIME_WAIT等待，关闭前个连接后，主动方与被动方又建立起新的TCP连接，这时被动方重传或延时过来的FIN包过来后会直接影响新的TCP连接；
同样网络情况不好并且无TIME_WAIT等待，关闭连接后无新连接，当接收到被动方重传或延迟的FIN包后，会给被动方回一个RST包，可能会影响被动方其它的服务连接。
过多的话会占用内存，一个TIME_WAIT占用4k大小

## TCP三次握手两次行不行？
- 电话通了，场景一
玲玲：我们下午3点出来约会吧。
李雷：3点没下课，4点吧。（有可能李雷4点到了，但是玲玲不愿意没有到，也就是没有建立连接）
如果是这样结束，那就是两次握手，李雷注定单身。
- 电话通了，场景二
玲玲：我们下午3点出来约会吧。
李雷：3点没下课，4点吧。
玲玲：好的，4点见。  （双方都说话了几点见，那么就说明建立了连接）
这就是三次握手的作用！


#虚拟内存技术

# 线程之间的同步方式
## 互斥量（Mutex）
	- synchronized，ReetentLock
## 信号量（Semphares）
	- 他允许同一时间多个线程访问同一个资源，但是需要控制同一时间的线程数。
## 事件触发（生产者消费者模式）
	- wait、notify

# 编程题
- 1 1593. 拆分字符串使唯一子字符串的数目最大
	- https://leetcode-cn.com/problems/split-a-string-into-the-max-number-of-unique-substrings/



# 设计题
- 设计一个抢红包系统（不能超卖，不能少买）
https://www.jianshu.com/p/87c98fd7ceef
	- 方案一，使用内存操作替代实时的DB事务操作。：将“实时扣库存”的行为上移到内存Cache中操作，然后异步落DB持久化。
		- 优点：提高了并发性能。
		- 缺点：在内存操作成功但DB持久化失败，或者内存Cache故障的情况下，DB持久化会丢数据，不适合微信红包这种资金交易系统。
	- 方案二，使用乐观锁替代悲观锁。
		- 1. 在并发抢到相同版本号的拆红包请求中，只有一个能拆红包成功，其他的请求将事务回滚并返回失败，给用户报错，用户体验完全不可接受。
		- 2. 将会导致第一时间同时拆红包的用户有一部分直接返回失败，反而那些“手慢”的用户，有可能因为并发减小后拆红包成功，这会带来用户体验上的负面影响。
		- 3.会带来大数量的无效更新请求、事务回滚，给DB造成不必要的额外压力。

	- 微信红包系统的高并发解决方案
		- 1.微信红包系统生成一个ID作为这个红包的唯一标识。 根据ID取模等方式 负载均衡的分布到分布式服务器中。
		- 2.逻辑Server层将请求排队，解决DB并发问题。
			- 使用Redis key来控制请求数量，超过一定数量就拒绝（比如：10块钱，分为20个红包，那么并发请求就是20，多余的直接返回提示“红包已经被抢完！”）
			- 使用消息队列来控制处理的请求的顺序。一个处理完在处理另一个
		- 3.双维度库表设计，保障系统性能稳定
			- 初期是根据红包ID的hash值分为多库多表。
			- 红包过期机制，超过24小时的红包都会变的失效。可以异步删除过期红包，降低数据的存储压力。
			- 当前的热红包数据，我们将数据加载到缓存当中（一般都是抢完的红包，提供查看对应信息的），降低数据库压力。

		- 4. 异步队列：将红包金额的发放放入队列中异步的发放。

- 设计一个淘宝订单系统，需求：买家能看到自己的订单，商家能看到自己出售的订单