# 一 判断对象是否存活的方法
## 引用计数法
- 引用计数算法（Reference Counting）是这样的：给对象添加一个引用计数器，每当一个地方引用它时，计数值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。
    - 使用该方法的语言：Python，游戏脚本领域使用的Squirrel语言
    - 优点：实现简单，判定效率高，大部分情况下是个不错的算法
    - 缺点：无法解决循环引用的问题，所有java并没有使用它来管理内存
    - 循环依赖实例
        - 实例A中有B的引用，实例B中有A的引用
         ```
            A A = new A()
            B B = new B()
            A.b = B;
            B.a = A; 
            A = null;
            B = null;
            System.gc();//这样来垃圾回收并不会回收掉A和B
         ```
    
## 可达性分析算法 GC Root
- 在主流的商用程序语言的主流实现中java，C#，都是通过可达性分析（Reachability Analysis）来判定对象是否存活。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连，则证明此对象不可用。
- 可以作为GC Root的对象：
    - JVM栈（栈帧中的本地变量表）中引用的对象
    - 方法区内类静态属性引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈中JNI（Native方法）引用的对象
# 二 Java中的引用对象的类型
- 强引用：通过new产生的对象，只要强引用还在，gc就不会回收掉被引用的对象
- 软引用（SoftReference类）：在系统将要发生内存溢出异常之前，将会把这些对象列入回收范围进行第二次回收。如果这次回收还是没有足够的内存才会抛出OOM。
- 弱引用（WeakReference类）：被弱引用关联的对象只能生存到下一次垃圾收集发生之前。无论是否有足够的内存都会被回收掉。
- 虚引用（PhantomReference类）：它是最弱的一种引用关系。一个对象是否有虚引用完全不会对其生存时间造成影响，也无法通过虚引用来获得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知（这个例子在java编程思想并发编程中有用过）。
- 练习

# 三 对象的生存与死亡，这是个问题，嗯！
- 即使在可达性分析算法中不可达的对象，也有一次自我救赎的机会。要真正宣告一个对象死亡，还有经过以下过程：
    - 判断对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法或者该方法已经在之前被调用过一次，那么虚拟机将视其为没有必要执行，该对象即将被回收。
    - 如果对象有必要执行finalize()方法，在执行了该方法后，该对象可达（不可达依旧会被回收），则将其移出即将回收的集合。这是对象拯救自己的唯一方式。
    - **两次标记：1 判断没有与GC Roots相连之后进行一次标记  2 执行finalize()方法，之后进行第二次标记**
- **finalize()最多只会被系统自动调用一次** 在这一次的调用过程中，可以通过将自己的this指针赋值给某个类变量或者对象的成员变量来**拯救自己一次**，
但是当第二次在gc的时候就不会存活了，忘记finalize()这个方法！！！
    - 测试参考：/Users/chenyunbin/Documents/我的idea项目/cyb_springboot_test/src/main/java/com/cyb/codetest/JVM/FinalizeEscapeGCTest.java
 
 
# 四 回收方法区
- HotSpot虚拟机的永久代
- 永久代的gc只要回收两部分内容
    - 废弃常量：没有任何一个引用，引用常量池中的常量，那么就可以回收
        - String a = "abc";  没有任何的引用 引用了 "abc"时，"abc"就可以回收。
    - 无用的类：回收的条件比较苛刻
        - 1 该类所有的实例都被回收，java堆中不存在该类的任何实例
        - 2 加载该类的ClassLoader已经被回收
        - 3 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
        - 满足以上三个条件才有可能呗JVM回收掉

# 五 垃圾收集算法
## 标记-清除算法
- 标记出需要所有需要回收的对象，标记完成后统一回收所有被标记的对象。
    - 两次标记：1 判断没有与GC Roots相连之后进行一次标记  2 执行finalize()方法，之后进行第二次标记
    - 这是最基础的gc算法，是因为后续的gc算法都是基于这种思路并对其不足进行改制而得到，
    - 不足之处：
        - 1 效率问题：标记和清除两个过程的效率都不够高
        - 2 空间问题：标记清除之后会产生很多的不连续的内存碎片，碎片太多有可能会导致找不到足够的大小来存放一些较大的对象 而不得不产生新的一次的gc，影响效率。
 
## 复制算法
- 将内存划分为大小相等的两块，一块内存用完了，将存活的对象移动到另一块，循环往复。
- 不足：内存利用率太低，有一半的内存无法利用
- 优点：简单 效率高
- 重点来喽，也是考点！
    - 现在的商业JVM都采用复制算法来**回收新生代**，IBM公司的专门研究表明，新生代中的对象98%是 "朝生夕死" 的，所以并不需要1：1的比例来划分内存空间。
    - 实际上sun公司的HotSpot VM 一直使用的就是 Eden：SurvivorFrom：SurvivorTo = 8：1：1，跟IBM研究没有半毛钱关系。
        - 当Eden与Survivor内存满了之后进行gc，将存活的对象放入另一块SurvivorTo，然后回收Eden与Survivor。
        - 当SurvivorTo不足以存储剩下的存活的对象时，就通过**分配担保机制**进入 老年代。
        
## 标记-整理算法
- 老年代的收集算法
    - 原因：复制收集算法在对象存活率较高的时候就要进行多次的复制操作，效率会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以老年代不能使用这种算法。
- 老年代的特点就是基本不会被回收    
- 根据老年代的特点，有人提出了另外一种标记-整理算法。标记过程和标记-清除算法一致，但后续步骤不是直接对可回收对象进行清理，而是让存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

## 分代收集算法
- 当前商业虚拟机的垃圾收集都采用分代收集算法，这种算法没什么新的思想，只是根据对象存活周期的不同将内存划分为几块。
一般是把Java堆分为新生代和老年代。在新生代使用复制算法，而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清理或标记-整理的算法来进行回收。

 
# 六 HotSpot的算法实现
- 枚举根节点
    - 从可达性分析 GC Roots找引用链为例，可作为GC Roots的节点主要是全局性的引用（如类静态变量，常量）与执行上下文（栈帧中的本地变量表）中。
    现在很多引用仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。
        - 在可达性分析的过程中不可以出现对象引用关系还在不断变化的情况，这一点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿Java的所有的线程的其中一个重要原因
        - Stop The World：sun将这件事称为 Stop The World 简称STW。即使是号称（几乎）不会发生停顿的CMS，枚举根节点也是要停顿的。
    - 目前主流JVM都是使用准确式GC:
        -**就是让JVM知道内存中某位置数据的类型什么**。比如当前内存位置中的数据究竟是一个整型变量还是一个引用类型。这样JVM可以很快确定所有引用类型的位置，从而更有针对性的进行GC roots枚举。
    - HotSpot是利用OopMap来实现准确式GC的。当类加载完成后，HotSpot 就将对象内存布局之中什么偏移量上数值是一个什么样的类型的数据这些信息存放到 OopMap 中；
        - 在 HotSpot 的 JIT 编译过程中，同样会插入相关指令来标明哪些位置存放的是对象引用等，这样在 GC 发生时，HotSpot 就可以直接扫描 OopMap 来获取对象引用的存储位置，从而进行 GC Roots 枚举。
        
- 安全点
    - HotSpot只在特定的位置记录了OopMap，这些位置就叫做安全点（Safepoint），也就是说，程序并不能在任意地方都可以停下来进行GC，只有到达安全点时才能暂停进行GC。
    - 安全点的位置：
        - (1) 循环的末尾 (防止大循环的时候一直不进入Safepoint，而其他线程在等待它进入Safepoint)
        - (2) 方法返回前
        - (3) 调用方法的call之后
        - (4) 抛出异常的位置
    - 安全点暂停线程运行的手段有两种
        - 抢先式中断
            - 不需要线程的执行代码主动配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上再暂停。**不过现在的虚拟机几乎没有采用此算法的**。
        - 主动式中断
            - GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时去主动轮询查询此标志，发现中断标志为真时就中断自己挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。
            
            
- HotSpot安全区域
    - 安全区域是指在一段代码片段内，引用关系不会发生变化，在这段区域内，任意地方开始GC都是安全的。 可以看做是扩展版的安全点
    - 产生原因
        - 安全点机制保证了程序执行时进入GC的问题。**但是对于非执行态下，如线程Sleep或者Block下，由于此时程序（线程）无法响应JVM的中断请求**，JVM也不太可能一直等待线程重新获取时间片，此时就需要安全区域(Safe Region)了。
    - 运行机理
        - 在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region。当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了；
        当线程要离开Safe Region时，如果整个GC完成，那线程可继续执行，否则它必须等待直到收到可以安全离开Safe Region的信号为止
      

# 七 垃圾收集器

## 年轻代收集器
- Serial
- ParNew
- Parallel Scavenge

## 老年代收集器
- CMS
- Serial Old
- Parallel Old
- G1
      