## G1
https://blog.csdn.net/u011069294/article/details/108280100

- **Remembered Set保证了 避免GC时的全堆扫描：** 
    - 1 每个region中都会有一个与之对应的Remembered Set
    - 2被引用对象的引用相关系会记录到它对应的Remembered Set中，这就保证了在可达性分析的时候 GC Root向下搜索引用的时候，直接查找Remembered Set就好
不用全对堆的去查找（比如 老年代对象OldObject引用了年轻代对象YObject ，直接查找Remembered Set中的引用关系就好）

- 优势
    - 1 并行与并发：多GC线程同时工作（并行），GC与用户线程交替执行（并发）
    - 2 分代收集：将堆划分为多个Region，不要求整个Eden区，年轻代，或者老年代都是连续的。兼顾年轻代和老年代的回收任务。
    - 3 内存碎片整理：
        - 1 region为回收单位，Region之间使用 **"复制算法"**
        - 2 整体上看是**标记-整理算法**，两种算法都能避免内存碎片。
        - 3 这种特性避免了**分配大对象**时不会因为找不到连续的空间而出发GC。 **尤其是Java堆越大，G1优势更大**
        - 4 可预测的停顿模型
            - 1 维护Region回收的优先级列表（回收所得空间大小和回收所需时间的经验值）
            - 2 长度为M的时间段，设置停顿时间不超过N ms
        - G1停顿在最差的情况要比CMS好很多。
        
- 缺点
    - 1 相比于CMS，还不具有压倒性优势。 
        - 比如GC收集产生的 **内存占用**，以及程序运行时的**额外执行负载（OverLoad）**都比CMS高
    - 2 经验上来说：小内存CMS大概率优于G1.  **平衡点在 6~8G之间。**
    - 3 想要大吞吐量G1不是个好的选择
- 配置参数
-XX:G1HeapRegionSize 设置每个region的大小，值只能是2的n次方（1,2，4,8，16,32），范围是1MB到32MB。
-XX:MaxGCPauseMillis 设置期望达到（JVM会尽力实现，**但不保证**）的最大GC停顿时间，默认是200ms。 
这个参数如果设置的过小，会导致一次回收的region个数减少，回收的垃圾对象减少(因为设置的垃圾线程工作的时间减少了)，
如果产生垃圾的速度很快，可能会导致Full GC。

-XX:ParallelGCThread 设置STW的时候并行的垃圾线程数量。
-XX:ConcGCThreads 设置用户线程与垃圾收集线程并发的时候，垃圾收集线程的线程数量

- **通常使用G1收集器，不需要那么多的参数配置**。只需要进行下图所示的3步。其他的参数，G1会自动调节或使用默认的参数。
    - 1 开启G1垃圾回收器（JDK1.9默认：取代了CMS以及Parallel + Parallel Old组合，在JDK7以及JDK8中，可以使用-XX:+UseG1GC来启用。）
    - 2 设置堆的最大内存
        -Xms4g  堆初始大小 4g
        -Xmx4g  最大堆大小 4g
    - 3 设置最大的停顿时间：-XX:MaxGCPauseMillis
- G1提供了三种垃圾回收模式：YoungGC，Mixed GC和 Full GC，在不同的条件下触发、。

- 应用场景：
    - 1 面向服务端应用有大内存，多处理器的机器（在普通大小堆里表现并不惊喜）
    - 2 主要的应用是需要低GC停顿延时，并具有大堆的应用程序提供解决方案
        - 如:在堆大小为约为6G或者更大时，可预测停顿时间可以低于0.5s
        - G1通过每次只清理一部分的而不是全部的Region（根据优先级排序过了）的增量式清理来保证每次GC停顿时间不会过长
    - 3 用来替代JDK1.5中CMS收集器，可能比CMS要好
        - 1 超过50%的Java堆被活动数据占用
        - 2 对象分配频率或者年代提升频率变化快（常见对象多 并且 年轻代晋升到老年代的对象更多）
        - 3 GC停顿时间过长（长于0.5~1s）
         
    - 4 HotSpot垃圾收集器 除了G1以外，其他的垃圾收集器使用JVM内置的线程执行GC的多线程操作。
    而G1可以使用应用线程来帮助GC回收过程。 



- 内存结构， Eden  S  Old  都是按照Region来进行划分的，但不是连续的。
    - young gc 与CMS类似，只是内存空间都是以Region划分，并不是连续的。
    - G1对于老年代的GC比较特殊，本质上不是只针对老年代，也有部分年轻代，**所以又叫MixGC。**
        - 初始标记：也是标记GC Root引用的对象 （STW），也就是RootRegion
        - Root Region Scan:与CMS有所不同， 扫描Old区的所有Region中的Remember set中是否有RootRegion。
             也就是是不是与GC Root有引用关系，如果有不就说明了不会被回收了么。
        - 并发标记：类似CMS，但是标记的是整个堆，而不是只有O区。这期间如果发现某个region所有对象都是'垃圾'则标记为X
        - 重新标记：类似CMS，但也是整个堆，并且上一步中的X区被删除。另外采用了初始标记阶段的SATB，重新标记的速度变快。
        - 复制/清理：选择所有Y区reigons和'对象存活率较低'的O区regions组成Csets，进行复制清理。
            
            
    
    
- 每一个Region的大小一般是 1M~32M（可以配置）  大概是2000个Region。
- 每一个Region区域内都会有一个Remember Set 的结构用来存储： 其他对象引用当前Region 对象的记录
- Collection Set：本次GC需要清理的Region集合