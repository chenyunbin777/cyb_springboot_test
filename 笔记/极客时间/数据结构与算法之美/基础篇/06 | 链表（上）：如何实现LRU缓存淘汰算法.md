# 06 | 链表（上）：如何实现LRU缓存淘汰算法?

## 单链表
- 最后一个节点的next是null

## 双向链表
- pre node next，最后一个节点的next是null，使用空间换时间的办法实现更快的查找删除，因为他会比单链表与循环链表多出一个pre指针会多出一倍的存储空间。

## 循环链表
- 最后一个节点的next是头结点

## 双向循环链表
- 


## 空间换时间
- **一般我们使用过的都是空间换时间的办法，因为在实际开发的产品对于时间效率的要求是最高的。**


## 时间换空间
- 在内存比较紧缺的情况下，可以使用该策略

## LRU Least Recently Used 最近最少使用策略

## LFU Least Frequently Used 最少使用策略


## 如何使用数组来实现一个LRU

Object[] = new Object[100];

当一个元素过来的时候 查询列表是否存在该元素，如果存在就把该元素obj放在0的位置上。
如果不存在，分两种情况
- 1 如果此时数组没有满那么就将次元素放到0的位置上，然后所有的元素要向后移动
- 2 如果数组满了就删除掉最后一个元素，然后所有的元素要向后移动


## 思考 单链表存储得字符串如何判断是回文？

1-》2-》3-》2-》1

- 1 遍历单链表 把元素都取出来放到数组中，然后在开头结尾一起遍历判断。 时间复杂度和空间复杂度都是O(n)
- 2 快慢指针法：