# 11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？
- 空间复杂度为O(1)的称为原地排序
## 冒泡
- 有序度：数组中的一对有序的元素，有序度就+1。
- 最坏的情况，初始状态有序度就是0，也就是是逆序的数组，所以要进行n*(n-1) /2次交换；
- 最好的情况，初始状态有序度就是n*(n-1) /2，进行0次交换。 取交换次数中间值n*(n-1) / 4 为平均时间复杂度

- 稳定的排序
```

    public void bubbleSort(int[] a, int n) {
        if (n <= 1) return;

        for (int i = 0; i < n; ++i) {
            // 提前退出冒泡循环的标志位
            boolean flag = false;
            for (int j = 0; j < n - i - 1; ++j) {
                if (a[j] > a[j + 1]) { // 交换，三次赋值操作
                    int tmp = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = tmp;
                    flag = true;  // 表示有数据交换
                }
            }
            if (!flag) break;  // 没有数据交换，提前退出
        }
    }
```


## 插入排序
- 将无序序列中的元素一个个的插入到有序的序列中，从序列的第一个元素开始为有序序列
- 第一，插入排序是原地排序算法吗？
    - 从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O ( 1 ) ，也就是说，这是一个原地排序算法。
- 第二，插入排序是稳定的排序算法吗？
    - 在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。
- 第三，插入排序的时间复杂度是多少？
    - 如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O ( n ）。注意，这里是从尾到头遍历已经有序的数据。如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O ( n^2 ）。
    
```
    public static void insertionSort(int[] a) {
        int n = a.length;
        if (n <= 1) return;

        for (int i = 1; i < n; ++i) {
            int value = a[i];
            int j = i - 1;
            // 查找插入的位置
            // 从前边有序的序列尾开始查找
            for (; j >= 0; --j) {
                if (a[j] > value) {
                    a[j + 1] = a[j];  // 一次数据移动，只有一次赋值操作
                } else {
                    break;
                }
            }
            a[j + 1] = value; // 插入数据
        }
    }

```
    
## 选择排序
- 选择排序思路：类似于插入排序，也是分为已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

- 不稳定，略逊色与冒泡和插入  

## 都是稳定的排序算法为什么要选择插入排序
- 