# 12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？

## 归并排序
- 思路：将一个序列分为两个序列，再将两个序列分为四个序列...一直向下分裂，
然后将每一个序列排好序，最后在将所有的序列合并在一起生成一个有序的序列的过程。

- 可以将一个问题拆分为多个子问题的情况就可以考虑使用递归来实现。
    - 1 写出递归公示
    - 2 结束条件
``` 
递推公式：
merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))

终止条件：
p >= r 不用再继续分解
```

- 性能分析
    - 是否稳定：可以写成稳定的也可以写成不稳定的。关键在于如果进行的两个子序列的合并操作，如果合并的时候判断元素相等时，将前边的序列优先放入数组中就可以保证稳定。
    - 时间复杂度：学习如何分析递归的时间复杂度
        - 我们定义求解问题a的时间是T(a),  T(a) = T(b) + T(c) + K 
        其中 K 等于将两个子问题b、 c 的结果合并成问题 a 的结果所消耗的时间。
        从刚刚的分析，我们可以得到一个重要的结论：不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。
        套用这个公式，我们来分析一下归并排序的时间复杂度。我们假设对 n 个元素进行归并排序需要的时间是 T ( n ) ，
        那分解成两个子数组排序的时间都是 T ( n / 2 ）。我们知道， merge ( ）函数合并两个有序子数组的时间复杂度是 O ( n ）。
        所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：

        T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。
        T(n) = 2*T(n/2) + n； n>1    ,这样递归的时间复杂度递推公式就出来了
        
     那么时间复杂度T(n)如何计算呢？   
     T(n) = 2*T(n/2) + n
     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
     ......
     = 2^k * T(n/2^k) + k * n
     ......
    
    - 空间复杂度度：O(n) 最大也就是tmp临时数组是arr的长度n
```
        for (; i <= mid && j <= end; ) {
            //这里<=保证了归并排序的稳定性,这样就可以保证前边的序列会优先的放入数组中
            if (arr[i] <= arr[j]) { 
                tmp[tmpIndex] = arr[i];
                i++;
            } else {
                tmp[tmpIndex] = arr[j];
                j++;
            }
            tmpIndex++;
        } 
```    
    
    
   
    
    
## 快排

