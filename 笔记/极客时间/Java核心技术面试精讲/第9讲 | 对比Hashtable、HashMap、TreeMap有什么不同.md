# 第9讲 | 对比Hashtable、HashMap、TreeMap有什么不同？

## HashMap
- transient Node<K,V>[] table;  存储HashMap元素的数据结构，是一个键值对类型的数组
- 负载因子loadFactor：描述HashMap最多可以负载的元素数量的百分比，它存在的目的就是要控制好HashMap的扩容阈值
- 容量capacity：可以在初始化的时候进行赋初值，默认是16
    - static final int DEFAULT_INITIAL_CAPACITY = 1 << 4
    
- 计算键值对在哈希表中的位置（数组index）取决于下面的位运算
    - i = (n - 1) & hash
    - 为什么要将高位的数据位移到低位进行异或运算呢？（异或 相同是0不同是1）：是因为有一些数据计算的hash值差异主要在高位，
    而hashmap里的哈希寻址是忽略容量以上的高位的，这样处理有效于避免hash碰撞。
    - 避免hash碰撞的好处就是可以让元素均匀的保存在hash表中，既不会让某一个桶节点的链表太长也不会太短，这样的存取效率的最高的。
    
    
- static final int TREEIFY_THRESHOLD = 8; 当链表的长度为8时会转换成红黑树
- static final int UNTREEIFY_THRESHOLD = 6; 当链表的长度为6时会转换成链表
    - 中间有个差值7可以有效防止链表和树频繁转换。
    - 为什么设置8转换为树形结构？
        - 1 因为log(n) = log(8) = 3 平均查找长度为3，那么这时链表的平均查找长度就是 8/2 = 4属性结构更快。
        - log(n) = log(16) = 4，然而 16 / 2 = 8，在n越大的时候属性结构的优势越大。
        - 2 n = 6的时候，链表 = 6/2 = 3 树形：log(6) = 2.xxx,这时树形也有优势为什么不转换为树形呢？是因为链表转换为红黑树也是需要时间的效率会更低
    
    
    
- 为什么要树化
     - 而树化(使用红黑树）能将时间复杂度降到O(logn)，从而避免查询时间过长。


- resize扩容机制
    - 扩容的阈值》=loadFactor * size 时进行扩容，扩容为之前的2倍
    
- 为什么hashmap的size都是2的n次幂
    - HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法；
      这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算，源码中做了优化hash&(length-1)，
      **hash%length==hash&(length-1)的前提是length是2的n次方；**
      为什么这样能均匀分布减少碰撞呢？2的n次方实际就是1后面n个0，2的n次方-1  实际就是n个1；
      例如长度为9时候，3&(9-1)=0  2&(9-1)=0 ，都在0上，碰撞了；
      例如长度为8时候，3&(8-1)=3  2&(8-1)=2 ，不同位置上，不碰撞；
