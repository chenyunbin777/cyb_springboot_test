# 第4讲 | 强引用、软引用、弱引用、幻象引用有什么区别？



## 强引用
我自己的总结：下面可以使强引用的拓展，在面试的时候可以多说一点自己的认识与理解
new 出来的对象，对象的创建与回收都是jvm来控制的。
- 对象的创建就分为几个步骤：
- 判断对象是否可达的状态：1 引用计数法  2 可达性分析：GC Root
- gc回收策略
- gc回收器

评论总结：
- 我们平常典型编码Object obj = new Object()中的obj就是强引用。
- 通过关键字new创建的对象所关联的引用就是强引用。 
- 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠**随意回收**具有强引用的“存活”对象来解决内存不足的问题。
- 对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看**垃圾收集策略**。

## 软引用
- 在内存快要溢出OOM的情况时，会进行回收。他是内存敏感型的引用。可以将一些相关的对象设置为软引用防止OOM
- 特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：
即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，
如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。
后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。
- **可以不与ReferenceQueue一起使用**

- 应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。

## 弱引用
- SoftReference
- 在每次GC的时候都会被回收，。可以作为
-弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，
一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。
弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。
- **可以不与ReferenceQueue一起使用**
- 应用场景：弱应用同样可用于内存敏感的缓存。

## 虚幻引用
- 只是在虚幻引用引用的实例对象被回收的时候发出一个通知。可以作为对象回收的监听，从而做出一些逻辑处理
- - **必须与ReferenceQueue一起使用**
```
ReferenceQueue queue = new ReferenceQueue ();
PhantomReference pr = new PhantomReference (object, queue);
```

- 应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。