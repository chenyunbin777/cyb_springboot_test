# 实现一个非代码侵入的透传参数
- 我们想实现通过一个traceId将一次请求的整个链路串联起来。通过查询traceId就可以查询出一条完整链路的所有日志信息。
- 思路：就是想办法将我们需要透传的数据保存起来，并且我们所有关联的服务都可以查询的到，**这样的话各个服务就可以使用这个透传的参数（traceId）与其他数据（日志，参数等）进行关联**。


- 1 可以使用redis实现，将下游服务需要的参数信息放置到redis中（hash set可以实现），下游服务就可以随时读取该数据。 
    - 过期时间可以根据测试不断完善，设置一个最优解。
- 2 可以使用数据库实现

- 业务端往往有这样的需求，它希望一些参数能在一次分布式请求一直传递下去，并且可以在不同的RPC中间件间传递。MTrace对该类需求提供了两个接口：
  put(map<String, String> data) ：参数可以在一次分布式请求中一直传递。 
  - 实现方式：当收到链路调用完成之后，将缓存失效。
  putOnce(map<String, String> data)： 参数在一次分布式请求中只传递一级。
  - 实现方式：将获取一次参数之后，将缓存失效。

# Tracing：微服务调用链追踪框架 Sky walking、Zipkin、Jaeger


# traceId的设计
- traceId全局唯一，64位整数，用于标识一次分布式请求，会在RPC调用的网络中传递。

# span
- 跨度，用来记录具体调用了哪些服务。 可以设计一个简单的spanid，0, 0.1, 0.1.1, 0.2。用于标识一次RPC在分布式请求中的位置，比如0.2就是0节点服务调用的第二个服务。
- 要定义好各个服务的节点标识，如 v2：0 galaxy：1  download：2  upload：3      0.1 0.2 0.3  代表了v2调用了galaxy，download，upload。 这个小小的数字中记录了当前节点信息和父节点信息（调用者信息）

# 分布式会话跟踪系统架构设计与实践
- 核心概念：调用链； 用途：定位系统瓶颈，优化系统结构（服务调用次数）、统计系统指标（调用次数，调用时间，各个服务调用的频率）、分析系统数据（服务调用开始，结束时间，服务异常，qps等）； 
架构：埋点上报、收集计算、展示分析。
## 优化链路
- 一次请求调用相同的接口10几次甚至是几十次，这是我们不想看到的事情，那么整个系统能不能对这样的请求进行优化。批量请求或者提高整个系统调用的并行度。
- 离线hive：分析一个服务的 入度（有多少服务调用了该服务） 出度（该服务有调用了多少其他服务）
- kafka：服务解耦，数据延迟消费。减少瞬时QPS， 但是降低了时效性（这是可以做出的牺牲，增强可用性，降低时效性）
- 实时数据Hbase：调用链路数据的实时查询主要是通过Hbase，使用traceID作为RowKey，能天然的把一整条调用链聚合在一起，提高查询效率。

- 如果使用到ThreadLocal就需要注意线程的切换。比如：线程池中的线程切换