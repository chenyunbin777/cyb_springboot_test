# 关注数据库底层模型，了解索引结构
- N叉平衡二叉树，降低树的高度，提高查询效率


# InnoDB 的索引模型
- 主键索引，聚蔟索引，叶子节点存放整行的数据
- 非聚蔟索引，二级索引，存放**主键值**。 
    - 查询 通常需要根据主键值再去ID索引树搜索一次，这个过程叫回表
    
    

# 索引维护
- 自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOTNULL PRIMARY KEY AUTO_INCREMENT。
    - 自增主键的好处就是不会产生"页分裂" 或者 "页聚合"
- 而有业务逻辑的字段做主键，则往往**不容易保证有序插入**，这样写数据成本相对较高。
- 显然，主键长度越小（字节），普通索引的叶子节点就越小，普通索引占用的空间也就越小。

- **有没有什么场景适合用业务字段直接做主键的呢？** 还是有的。比如，有些业务的场景需求是这样 的：1. 只有一个索引； 2. 该索引必须是唯一索引。
    - 将这个索引设置为主键索引

# 问题
- 如何避免长事务对业务的影响？
    - 业务连接数据库的时候，根据业务本身的预估，通过**SETMAX_EXECUTION_TIME**命令来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。
    
    - 1.监控information_schema.Innodb_trx表，设置长事务阈值，超过就报警/或者kill；
    - 2.Percona的pt-kill这个工具不错，推荐使用；
    - 3.在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题；
    - 4.如果使用的是MySQL5.6或者更新版本，把innodb_undo_tablespaces设置成2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。
    
    
# 覆盖索引
- 如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值
  已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面， 索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。

# **建立冗余索引,提高查询效率** 
  
# 最左前缀原则
- 例子数据：... ID3(张六，30)....


- 索引项是按照索引定义里面出现的**字段顺序排序的**。
- 如果你要查的是所有名字第一个字是“张”的人，你的SQL语句的条件是"where name like ‘张%’"。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历， 直到不满足条件为止
- 可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。

- 根据需求确定联合索引的建立顺序，（name，age），满足根据身份证号查询地址”的需求。 如果需要根据age去查询的话，name还需要建立一个age的单独的索引。


# 索引下推
- 如果不符合 "最左前缀" 的部分如果处理？ 
 - （name, age）为例。如果现在有一个需求：检索出表中“名字第一 个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：
 - select * from tuser where name like '张%' and age=10 and ismale=1;
 
 - 在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。
 - 而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，
 **直接过滤掉不满足条件的记录**，**减少回表次数**。