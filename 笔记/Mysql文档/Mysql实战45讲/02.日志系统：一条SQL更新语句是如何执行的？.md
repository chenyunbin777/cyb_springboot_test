# 02.日志系统：一条SQL更新语句是如何执行的？
- 前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会 把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因


# 重要的日志模块：redo log
- 而粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是Write- Ahead Logging，
它的关键点就是先写日志，再写磁盘，也就是先写粉板(redo log)，等不忙的时候再写账本(dbs磁盘)。

- 问题：如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？
    - 这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把 这些记录从粉板上擦掉，
    为记新账腾出空间。
    - 与此类似，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，
    那么这块“粉板”总共就可以记录4GB的操作。从头开始写，**写到末尾就又回到开头循环写**，如下面这个图所示
    
    ----未使用----checkpoint-------已经使用的redo log--------write pos----未使用----
    🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
    
    - 有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为**crash-safe**。
    
    


# 重要的日志模块：binlog
- MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能 层面的事情；
还有一块是引擎层，负责存储相关的具体事宜。
    - 上面我们聊到的粉板redo log是 **InnoDB引擎特有的日志**，
    - 而Server层也有自己的日志，称为binlog（归档日志）。
    
# 二阶段提交
- update T set c=c+1 where ID=2;
- 将redo log的写入拆成两个部分
    - 1 prepare
    - 2 commit
    - 保证redo log与bin log的一致性。必须两个日志中的数据都存在，要不然可能产生数据不一致的情况。
- 例子
    1. 先写先 redo log r 后写后 binlog b 。假设在redo log写完，binlog还没有写完的时候，MySQL进程异 常重启。
    由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回 来，所以恢复后这一行c的值是1。
    但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份 日志的时候，存起来的binlog里面就没有这条语句。
     然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这 个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，
     与原库的值不同。 
    2. 先写先 binlog b 后写后 redo log r 。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以 后这个事务无效，
    所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日 志。所以在之后用binlog来恢复的时候就多了一个事务出来，
    恢复出来的这一行c的值就是 1，与原库的值不同。
    
    
# 小结
- innodb_flush_log_at_trx_commit：设置为1，保证每次事务的redo log都直接持久化到磁盘。这样可以保证 MySQL异常重启之后数据不丢失
- sync_binlog：这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建 议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。


# 思考题
- 前面我说到定期全量备份的周期“取决于系统重要性，有 的是一天一备，有的是一周一备”。
那么在什么场景下，一天一备会比一周一备更有优势呢？或 者说，它影响了这个数据库系统的哪个指标？
    - 数据量比较大，数据库容易出问题的场景下，一天一备会比较有优势，
    - 如果数据库出现问题的情况下，可以最大限度保证了数据的一致性、完整性。大部分数据都可以保留下来。