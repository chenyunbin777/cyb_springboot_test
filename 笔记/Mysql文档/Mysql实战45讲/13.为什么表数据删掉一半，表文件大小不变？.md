# 13.为什么表数据删掉一半，表文件大小不变？



# 参数innodb_file_per_table

1. 这个参数设置为OFF表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；
2. 这个参数设置为ON表示的是，每个InnoDB表数据存储在一个以 .ibd为后缀的文件中。
3. 不论使用MySQL的哪个版本，都将这个值设置为ON。因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过drop table命令，系统就会直接删除这个文件。
而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。


# 数据删除流程
1. 数据页的复用跟记录的复用是不同的。
2. delete命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件 的大小是不会变的。而没有被 使用的空间，看起来就像是“空洞”
3. 不止是删除数据会造成空洞，插入数据也会
   - 数据是随机插入的，就可能造成索引的**数据页分裂**,
   - 如果某一个**数据页已经满了**，要在其中间在插入一跳记录就会发生页分裂。
4. 也就是说，经过**大量增删改**的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。
而重建表，就可以达到这样的目的。


# 重建表
试想一下，如果你现在有一个表A，需要做空间收缩，为了把表中存在的空洞去掉，你可以怎么 做呢？
- 你可以使用alter table A engine=InnoDB命令来重建表。
- 复制替换：在MySQL 5.5版本之前，这个命令的执行流程跟我们前面描述的差不多，**区别只是这个临时表B不需要你自己创建**，MySQL会自动完成转存数据、交换表名、删除旧表的操作。

# 往临时表插入数据最花费时间-MYSQL如何优化？
- 在MySQL 5.6版本开始引入的Online DDL，对这个操作流程做了优化。
## 在线DDL流程
1. 建立一个临时文件，扫描表A主键的所有数据页； 
2. 用数据页中表A的记录生成B+树，存储到临时文件中； 
3. 生成临时文件的过程中，将所有对A的操作记录在一个日志文件（rowlog）中，对应的是图 中state2的状态； 
4. 临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的 数据文件，对应的就是图中state3的状态； 
5. 用临时文件替换表A的数据文件

- 对于**一个大表**来说，Online DDL最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接受增删改操作。所以，相对于整个DDL过程来说，锁的时间非常短。对业务来说就可以认为是Online的。
- 上述的这些重建方法都会扫描原表数据和构建临时文件。对于很大的表来 说，这个操作是很消耗IO和CPU资源的。因此，如果是**线上服务**，你要很小心地控制操作时间。
如果想要比较安全的操作的话，我推荐你使用GitHub开源的**gh-ost来做**。


# 
从MySQL 5.6版本开始，
- alter table t engine = InnoDB（也就是recreate）默认的就是上面图4 的流程了； 
- analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程 中加了MDL读锁； 
- optimize table t 等于recreate+analyze。


# 小结
- 今天这篇文章，我和你讨论了数据库中收缩表空间的方法。 现在你已经知道了，如果要收缩一个表，只是delete掉表里面不用的数据的话，表文件的大小是不会变的，你还要通过alter table命令重建表，才能达到表文件变小的目的。
- 我跟你介绍了重建表的两种实现方式，Online DDL的方式是可以考虑在业务低峰期使用的，**而MySQL 5.5及之前的版本，这个命令是会阻塞DML的，这个你需要特别小心。**

# 问题
