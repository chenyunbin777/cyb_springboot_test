# 26.备库为什么会延迟好几个小时？
- 如果备库执行日志的速度持续低于主库生成日志的速度，那这个延迟就有可能成了小时级别。而且对于一个压力持续比较高的主库来说，**备库很可能永远都追不上主库的节奏**。
- 目的：就是让备库与主库数据备份速度一致

# 备库并行复制能力
- 在官方的**5.6版本之前，MySQL只支持单线程复制**，由此在主库并发高、TPS高时就会出现严重的主备延迟问题。
- 每个worker线程对应一个hash表，用于保存当前正在这个worker的“执行队列”里的事务所涉及的表。
hash表的key是“库名.表名”，value是一个数字，表示队列中有多少个事务修改这个表
在有事务分配给worker时，事务里面涉及的表会被加到对应的hash表中。worker执行完成后，这 个表会被从hash表中去掉。



# MariaDB 的并行复制策略
- redo log组提交(group commit)优化， 而MariaDB的并行复制策 略利用的就是这个特性：
1. 能够在同一组里提交的事务，一定不会修改同一行； 
2. 主库上可以并行执行的事务，备库上也一定是可以并行执行的。
- 缺点：
  - 在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行， 这样系统的吞吐量就不够
  - 这个方案很容易被大事务拖后腿。假设trx2是一个超大事务，那么在备库应用的时 候，trx1和trx3执行完成后，就只能等trx2完全执行完成，下一组才能开始执行。这段时间，只有 一个worker线程在工作，是对资源的浪费。



# MySQL 5.7 的并行复制策略
- 在MariaDB并行复制实现之后，官方的MySQL5.7版本也提供了类似的功能，由参数slave- parallel-type来控制并行复制策略：
1. 配置为DATABASE，表示使用MySQL 5.6版本的按库并行策略； 
2. 配置为 LOGICAL_CLOCK，表示的就是类似MariaDB的策略。不过，MySQL 5.7这个策略，针对并行度做了优化。这个优化的思路也很有趣儿。
3. MySQL 5.7并行复制策略的思想是： 
 - 1、同时处于prepare状态的事务，在备库执行时是可以并行的； 
 - 2、处于prepare状态的事务，与处于commit状态的事务之间，在备库执行时也是可以并行的。
 - prepare commit 都是 commit命令中的一个步骤

# MySQL 5.7.22 的并行复制策略
- 在2018年4月份发布的MySQL 5.7.22版本里，MySQL增加了一个新的并行复制策略，基于 WRITESET的并行复制。
- 相应地，新增了一个**参数binlog-transaction-dependency-tracking**，用来控制是否启用这个新策 略。这个参数的可选值有以下三种。
  1. COMMIT_ORDER，表示的就是前面介绍的，根据同时进入prepare和commit来判断是否可以并行的策略。 
  2. WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的hash值，组成集合 writeset。**如果两个事务没有操作相同的行**，也就是说它们的writeset没有交集，就可以并行。 
  3. WRITESET_SESSION，是在WRITESET的基础上多了一个约束，即在主库上同一个线程 先后执行的两个事务，在备库执行的时候，要**保证相同的先后顺序**。



# 小结
- 为什么要有多线程复制呢？
  - 这是因为单线程复制的能力全面低于多线程复制，对于更新压力较大 的主库，备库是可能一直追不上主库的。从现象上看就是，备库上seconds_behind_master的值 越来越大。
- 大事务不仅会影响到主库，也是造成备库复制延迟的主要原因之一。
- binlog协议并不是向上 兼容的，在主备切换、版本升级的时候需要把这个因素也考虑进去。