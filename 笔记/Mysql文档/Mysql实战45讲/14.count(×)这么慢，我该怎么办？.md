# 14.count(×)这么慢，我该怎么办？
1. count(*)语句到底是怎样实现的?
2. 以及MySQL为什么会这么实现。
3. 如果应用中有这种频繁变更并需要统计表行数的需求，业务设计上可以怎么做

# innodb与myisam的不同
1. MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数， 效率很高； 如果加了where 条件的话，MyISAM表也是不能返回得这么快的。
2. 而InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据**一行一行**地从引擎里面读出来，然后累积计数。


# 为什么InnoDB不跟MyISAM一样，也把数字存起来呢？
- 事务的原因，不能准确的算出对应的数量。MVCC
## 小结 
1. MyISAM表虽然count(*)很快，但是不支持事务； 
2. showtable status命令虽然返回很快，但是不准确； 
3. InnoDB表直接count(*)会遍历全表，虽然结果准确，但会导致性能问题。

## 解决办法
- 用户自己来计数
1. 用缓存系统保存计数，会有精度丢失，缓存丢失的情况，持久化数据丢失。Redis与DB同步**不是原子操作**
2. 在数据库保存计数，server层要什么字段，InnoDB就返回什么字段。
    - count(1)执行得要比count(主键id)快。因为从引擎 返回id会涉及到解析数据行，以及拷贝字段值的操作
    - count(字段)：字段不是null就会计数。
    - 但 count(*) 是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(*)肯定不 是null，按行累加。
3. 所以结论是：按照效率排序的话，count(字段)<count(主键id)<count(1)≈count(*)，所以我建议 你，**尽量使用count(*)**。