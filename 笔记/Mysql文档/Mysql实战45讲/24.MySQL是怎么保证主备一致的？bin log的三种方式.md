# 24.MySQL是怎么保证主备一致的？


# MySQL 主备的基本原理
## 在主备模式中，建议备用节点设置readonly（虽然没有访问到），原因
- 1、有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；
- 2、防止切换逻辑有bug，比如切换过程中出现双写，造成主备不一致；
- 3、可以用readonly状态，来判断节点的角色。

## 同步流程

1. 在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个 位置开始请求binlog，这个位置包含文件名和日志偏移量。 
2. 在备库B上执行start slave命令，这时候备库会启动两个线程，就是图中的io_thread和 sql_thread。**其中io_thread负责与主库建立连接**。 
3. **主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B。** 
4. **备库B拿到binlog后，写到本地文件，称为中转日志（relay log）。** 
5. sql_thread读取中转日志，解析出日志里的命令，并执行
6. 备注：后来由于多线程复制方案的引入，sql_thread演化成为了多个线程

## 三种bin log形式
1. statement：以事务的形式存储所有的mysql 的sql语句，并且在最后记录xid，也就是事务id。
   - 缺点：不记录语句的上下文数据，只记录sql语句，可能会有丢失数据的情况。
     - 比如说一些实时计算的函数，跟执行时当前的时间有关系，这样就会出现数据不一致的情况。
   -  insert into t values(10,10, now());  ：now()函数会自动转换成命令**SET TIMESTAMP**执行，所以不会产生数据不一致的情况
2. row：通过记录每一个row的变化情况，从而可以实现所有sql语句的日志记录，实时记录数据库的变化情况。但是这种模式相对来说比较耗费空间，并且可能会对性能产生影响。
   - 缺点：很占空间
   - 好处：恢复数据：现在越来越多的场景要求把MySQL的binlog格式设置成row。这么做的理由有很多，我来给你举一个可以直接看出来的好处：恢复数据
     - row格式的binlog也会把被删掉的行的整行 信息保存起来
     - 如果执行的是update语句的话，binlog里面会记录修改前整行的数据和修改后的整行数据。
     - row格式下，insert语句的binlog里会记录所有的 字段信息，这些信息可以用来**精确定位刚刚被插入的那一行**。
     这时，你直接把insert语句转成 delete语句，删除掉这被误插入的一行数据就可以了。
3. mixed：mysql来判断使用1 2哪一种方式来记录bin log
4. 数**log_slave_updates**设置为on，表示备库执行relay log 后生成binlog


# 双M结构的节点复制问题&解决
- 节点A和B 之间总是互为主备关系。这样在切换的时候就不用再修改主备关系。
- 问题：循环执行对方同步过来的bin log
- 解决办法：主要通过server id来区分
1. 规定两个库的**server id**必须不同，如果相同，则它们之间不能设定为主备关系； 
2. 一个备库接到binlog并在重放的过程中，生成与原binlog的server id相同的新的binlog； 
3. 每个库在收到从自己的主库发过来的日志后，先判断server id，如果跟自己的相同，表示这
     个日志是自己生成的，就直接丢弃这个日志。