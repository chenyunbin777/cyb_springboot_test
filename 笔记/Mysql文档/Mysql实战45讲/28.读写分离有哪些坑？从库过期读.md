# 28.读写分离有哪些坑？

# 从库过期读场景
主库上执行完成了三个事务trx1、trx2和trx3，其中：
1. trx1和trx2已经传到从库，并且已经执行完成了；
2. trx3在主库执行完成，并且已经回复给客户端，但是还没有传到从库中。
   如果这时候你在从库B上执行查询请求，按照我们上面的逻辑，从库认为已经没有同步延迟，但
   还是查不到trx3的。严格地说，就是出现了**过期读。**
   那么，这个问题有没有办法解决呢？

## 配合semi-sync
- 要解决这个问题，就要引入半同步复制，也就是semi-sync replication
- semi-sync做了这样的设计：
1. 事务提交的时候，主库把binlog发给从库；
2. 从库收到binlog以后，**发回给主库一个ack**（并没有全部刷盘之后在返回Ack，所以是半同步），表示收到了；
3. 主库收到这个ack以后，才能给客户端返回“事务完成”的确认。
- 问题：如果主库掉电的时候，有些binlog还来不及发给从库**，会导致系统数据丢失**
1. 一主多从的时候，在某些从库执行查询请求会存在过期读的现象；
2. 在持续延迟的情况下，可能出现过度等待的问题。


# 等主库位点方案
- 解决从库更新跟不上主库的问题。
```
select master_pos_wait(file, pos[, timeout]);
```
1. 它是在从库执行的；
2. 参数file和pos指的是主库上的文件名和位置；
3. timeout可选，设置为正整数N表示这个函数最多等待N秒
4. 返回值：这个命令**正常返回**的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。
   当然，除了正常返回一个正整数M外，这条命令还会返回一些其他结果，包括：
   - 1. 如果执行期间，备库同步线程发生异常，则返回NULL；
   - 2. 如果等待超过N秒，就返回-1；
   - 3. **如果刚开始执行的时候，就发现已经执行过这个位置了，则返回0。**

## 过期读的解决流程
1. trx1事务更新完成后，马上执行show master status得到当前主库执行到的File和Position；
2. 选定一个从库执行查询语句；
3. 在从库上执行select master_pos_wait(File, Position, 1)；  查询1秒内返回的结果
4. **如果返回值是>=0的正整数，则在这个从库执行查询语句；**
5. 否则，到主库执行查询语句。
- 问题：
1. 如果同步时间超过了1s的话，那么也是一个过期读 
2. 如果都是过期读，就会对与主库造成一些压力。
3. 不允许过期读的要求，就只有两种选择，一种是超时放弃，一种是转到主库
   查询。具体怎么选择，就需要业务开发同学做好**限流策略**了。



## GTID 方案
- 如果你的数据库开启了GTID模式，对应的也有等待GTID的方案。

```
select wait_for_executed_gtid_set(gtid_set, 1);
```
这条命令的逻辑是：
1. 等待，直到这个库执行的事务中包含传入的gtid_set，返回0；
2. 超时返回1。

- 同步流程
1. trx1事务更新完成后，**从返回包直接获取这个事务的GTID**，记为gtid1；
2. 选定一个从库执行查询语句；
3. 在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；
4. 如果返回值是0，则在这个从库执行查询语句；
5. 否则，到主库执行查询语句。
- 跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。

## 怎么能够让MySQL在执行事务后，返回包中带上GTID呢
- 你只需要将参数session_track_gtids设置为OWN_GTID，然后通过API接口mysql_session_track_get_first从返回包解析出GTID的值即可
- 这里我再回答一下。其实，MySQL并没有提供这类接口的SQL用法，是提供给程序的
  API(https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html)



# 问题：假设你的系统采用了我们文中介绍的最后一个方案，也就是等GTID的方案，现在你要对主库的一张大表做DDL，可能会出现什么情况呢？为了避免这种情况，你会怎么做呢？
- 出现的问题：从库同步数据延迟时间会很长，导致以上两种方案超时，读到主库上。
- 如何解决：直接读主库，设置超时时间长一点
- 用gh-ost方案



MariaDB MaxScale