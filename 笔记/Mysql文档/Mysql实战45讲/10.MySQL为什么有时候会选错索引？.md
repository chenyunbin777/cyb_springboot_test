# 10.MySQL为什么有时候会选错索引？
- 不知道你有没有碰到过这种情况，一条本来可以执行得很快的语句，却由于MySQL选错了索引，而导致执行速度变得很慢？
```
CREATE TABLE `t` ( 
    `id` int(11) NOT NULL, 
    `a` int(11) DEFAULT NULL, 
    `b` int(11) DEFAULT NULL, 
    PRIMARY 
    KEY (`id`), 
    KEY `a` (`a`), 
    KEY `b` (`b`) 
) ENGINE=InnoDB；
```
# 优化器的逻辑
- 选择索引是优化器的工作
- 判断标准：
  - 1、**扫描数据行数**，**这个是主要的原因**
  - 2、是否使用临时表、是否排序
  - 3、基数统计（cardinality）
  - 4、是否回表查询
- 扫描行数是怎么判断的？
  - MySQL在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据**统计信息**来**估算**记录数
  - 区分度：一个索引上不同的值越多，**这个索引的区分度就越好。** 索引上不同的值的个数，我们称之为“基数”（cardinality）。
  - show index from t; 进行查询
- MySQL 是怎样得到索引的基数的呢？
  - 采样统计：采样统计的时候，InnoDB默认会**选择N个数据页**，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。

# 索引选择异常和处理
- 1、我们还可以通过强制使用索引来指定，我们自己任务的效率最高的索引
  - force index
  - 缺点：这么写不优美，二来如果索引改了名字，这个语句 
  - mysql> explain select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 1; 也得改，显得很麻烦。
而且如果以后迁移到别的数据库的话，这个语法还可能会不兼容。

- 2、**使用analyze table tableName 来重新统计索引信息**，这样可以使explain统计的rows更准确
    - 如果你发现explain的结果预估的rows值跟实际情况差距比较大，可以采用这个 方法来处理
- 3、在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。
  - 如果优化器错误选择的索引其实根本没有必要存在，我们其实是可以进行删除的

# 小结
- 今天我们一起聊了聊索引统计的更新机制，并提到了优化器存在选错索引的可能性。
- 对于由于索引统计信息不准确导致的问题，你可以用analyze table来解决。 
- 而对于其他优化器误判的情况，你可以在应用端用force index来强行指定索引，也可以通过修改 语句来引导优化器，还可以通过增加或者删除索引来绕过这个问题。