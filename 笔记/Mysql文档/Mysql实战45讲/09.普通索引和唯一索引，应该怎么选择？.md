# 09.普通索引和唯一索引，应该怎么选择？
## 一些概念
- buffer pool
- change buffer
- 随机IO访问

# buffer pool的使用
- change buffer用的是buffer pool里的内存，因此不能无限增大。change buffer的大小，可以通 过参数innodb_change_buffer_max_size来动态设置。
这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。
- merge操作
  - 将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。
  - 1、除了访问这个数据页会触发merge外，
  - 2、系统有后台线程会定期merge。
  - 3、在数据库正常关闭（shutdown）的过程中，也会执行merge操作

## 什么条件下可以使用change buffer呢？
- 1、唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。因为更新时，唯一索引会将数据页读取到内存当中。
- 2、为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动 作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面 上要更新的次数越多），收益就越大
  - 因此，对**于写多读少的业务**来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。
- 3、假设**一个业务的更新模式是写入之后马上会做查询**，那么即使满足了条件，将更新先记 录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。
这样随机访问 IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。

# 查询过程
- 执行查询的语句是 select id from T where k=5。
- 1、对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。
- 2、对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。

# 更新中-唯一索引与普通索引的区别
- 1、唯一索引在更新中，需要**将数据页将读入内存当中（随机IO访问）**，判断唯一索引是否冲突，然后在插入这个值。
- 2、普通索引，直接将更新记录放在change buffer中，语句就执行结束了，之后将change buffer中的结果应用到对应的数据页当中。
- 将数据从磁盘读入内存涉及**随机IO的访问**，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。

- redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer 主要节省的则是随机读磁盘的IO消耗

# 小结
- 由于**唯一索引用不上change buffer**的优化机制，因此如果业务可以接受，从性能角度出发我建 议你优先**考虑非唯一索引**。
- 