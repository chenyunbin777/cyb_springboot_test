# TCP 可靠的传输协议   TCP，Transmission Control Protocol
- 全双工，c s都可以发送数据，是可靠的传输协议
- 面向连接的、可靠的、基于字节流的传输层通信协议


# 一 三次握手协议
指的是在发送数据的准备阶段，服务器端和客户端之间需要进行三次交互：
（1）第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
（2）第二次握手：服务器收到syn包，必须确认客户的syn（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
（3）第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。连接建立后，客户端和服务器就可以开始进行数据传输了。

客户端：send 状态包 j ，等待服务器确认
服务端：send 状态包k，与j+1（说名服务端收到了客户端的消息）
客户端：send 状态包j+1，k+1, 说明客户端确认了服务端收到了消息，然后返回。此时client与server建立了连接。

# 二 四次挥手 拜拜，断开连接：中断连接端能够是Client端，也能够是Server端
- 1 假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，可是假设你还有数据没有发送完毕，
则不必急着关闭Socket，能够继续发送数据。
- 2 所以你先发送ACK，"告诉Client端，你的请求我收到了，可是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，
继续等待Server端的FIN报文。
- 3 当Server端确定数据已发送完毕，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。
- 4 Client端收到FIN报文后，"就知道能够关闭连接了，可是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入**TIME_WAIT**状态，假设Server端没有收到ACK则能够重传。
“，Server端收到ACK后，"就知道能够断开连接了"。Client端等待了2MSL后依旧没有收到回复，则证明Server端已正常关闭，那好，我Client端也能够关闭连接了。Ok，TCP连接就这样关闭了！


总结：
1 客户端发送关闭消息给服务端
2 服务端此时有可能还有消息需要发送只能返回一个确认收到 客户端关闭连接的请求
3 当服务端传输完数据之后，最终会发送一个服务端关闭连接的请求
4 此时Client端收到FIN报文后，"就知道能够关闭连接了，可是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入**TIME_WAIT**状态，在2ML之后
依旧没有收到回复，则证明Server端已正常关闭，那好，我Client端也能够关闭连接了。

2MSL：MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

FTP(File Transfer Protocol 文件传输协议)
DNS（Domain Name System 域名系统）

传输层安全性协议（英语：Transport Layer Security，缩写作TLS），及其前身安全套接层（Secure Sockets Layer，缩写作SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。

HTTP是不保存状态的协议，在http/1.1中所有链接默认是持久链接
http的缺点：1）通信使用明文（不加密），内容坑内会被窃听
2）不验证通信方的身份，因此有可能遭遇伪装
3)  无法证明报文的完整性，所有有可能已遭串改
HTTP+加密+认证+完整性保护 = HTTPS
HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已


# TCP 滑动窗口
- TCP 流量控制，主要使用滑动窗口协议，滑动窗口是接受数据端使用的窗口大小，用来告诉发送端接收端的缓存大小，
以此可以控制发送端发送数据的大小，从而达到流量控制的目的。这个窗口大小就是我们一次传输几个数据。对所有数据帧按顺序赋予编号，
发送方在发送过程中始终保持着一个发送窗口，只有落在发送窗口内的帧才允许被发送；同时接收方也维持着一个接收窗口，
只有落在接收窗口内的帧才允许接收。

# TCP 粘包和拆包
- 概念
    - 粘包：发送数据小于发送缓冲区的大小，tcp会将多个数据放在一起发送
    - 拆包：要发送的数据大于 **TCP发送缓冲区**剩余空间大小，将会发生拆包。

- 解决方式
    -1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
    -2、发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
    -3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。
- netty解决方案
    - FixedLengthFrameDecoder：固定长度的粘包和拆包，该解码一器会每次读取固定长度的消息
    - DelimiterBasedFrameDecoder（添加特殊分隔符报文来分包）   
    

## 一 如何解决网络拥堵：
为了进行拥塞控制，TCP发送方要维持一个“拥塞窗口”的状态变量，大小取决于网路的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口 和 接收方的接收窗口取最小的一个
	- 拥塞窗口：Congestion Window ，简称：cwnd
	- 1 慢开始（slow - start）：探测，窗口逐渐增大，cwnd初始为1，没经过一个轮次的传播，cwnd加倍。
	- 2 堵塞避免（congestion avoidance）：也是cwnd缓慢增大， 每经过一个往返时间RTT 就把发送方的cwnd+1
	- 3 快重传（fast retransmit），快恢复（fast recovery）：可以快的恢复丢失的数据包，如果接受端收到了一个不按顺序的数据段，他会给发送端发送一个重复确认ACk。
	如果接收端连续发送了3个ACK的话说明有数据段丢失了，并立即重传这些丢失的数据，并且快速的恢复数据。

## 二 如何保证可靠传输
- 1 应用数据被分割成TCP认为最合适的发送的数据块
- 2 TCP给发送的每一个包进行编号ID，接收端对数据包进行排序，把有序数据传输给应用层
- 3 校验和：目的是检测数据在传输中的任何变化。如何收到的检验和由差错，TCP将丢弃这个报文段和不确认收到此报文段。
- 4 流量控制：TCP使用滑动窗口实现流量控制，也就是滑动窗口。
- 5 拥塞控制：当网络拥塞时，减少数据的发送
- 6 停止等待协议：为了实现可靠传输，他的基本原理就是每发送完一个分组就停止发送，等待对方确认接收之后在发送下一个分组。
- 7 超时重传：发送端等待接收端确认，如果没有ACK回传，那么就会重发这个报文段。

## 三 TCP TimeWait怎么产生的？有什么危害？
- 1 TimeWait怎么产生的：在TCP四次挥手过程中，客户端最后接收到server的FIN关闭连接消息之后，会发送ACK确认消息；但是客户端不相信网络，server有可能接受不到这个ACK消息，那么他会等待2MSL(最大报文段生存时间，默认30s一个)才会关闭连接状态。
- 2 有什么危害：TimeWait太多可能产生2类报错，TimeWait溢出（一个TIME_WAIT占用4k大小）或者是无法新建连接的（端口号耗尽） ，
		server端产生，则可能引起雪崩，要避免server主动关闭连接。
		
# TIME_WAIT过多危害
网络情况不好时，如果主动方无TIME_WAIT等待，关闭前个连接后，主动方与被动方又建立起新的TCP连接，这时被动方重传或延时过来的FIN包过来后会直接影响新的TCP连接；
同样网络情况不好并且无TIME_WAIT等待，关闭连接后无新连接，当接收到被动方重传或延迟的FIN包后，会给被动方回一个RST包，可能会影响被动方其它的服务连接。
过多的话会占用内存，一个TIME_WAIT占用4k大小

## TCP三次握手两次行不行？
- 电话通了，场景一
玲玲：我们下午3点出来约会吧。
李雷：3点没下课，4点吧。（有可能李雷4点到了，但是玲玲不愿意没有到，也就是没有建立连接）
如果是这样结束，那就是两次握手，李雷注定单身。
- 电话通了，场景二
玲玲：我们下午3点出来约会吧。
李雷：3点没下课，4点吧。
玲玲：好的，4点见。  （双方都说话了几点见，那么就说明建立了连接）
这就是三次握手的作用！

