# 一 JVM内存分哪几个区，每个区的作用是什么
- **堆：最重要**
    - 线程共享内存区域
    - 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在这里分配内存。
    - 是gc管理的主要区域
 
- jdk1.7称为方法区（也称永久代）jdk1.8称为元空间metaspace
    - 线程共享内存区域 
    - 存储的是JVM加载的类信息，常量，静态变量
    - 运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量和符号引用， 这部分内容将在类加载后进入运行时常亮池中存放。

- 程序计数器
    - 存储的是一个程序执行到哪里的“指针”。
    - 由于JVM的多线程是通过线程轮流切换并分配处理器cpu执行时间的方式来实现的，任何一个时间cpu都会执行一条线程中的指令。
        因此为了线程切换后能恢复到正确的执行位置，**每一个线程都会有一个单独的程序计数器**，各个线程之间互不影响，独立存储。
        我们称这类内存区域为 **"线程私有内存"**
    - 线程执行的是Java方法：计数器记录的是正在执行的JVM字节码指令地址。
    - Native方法：这个计数器值则为空（undefined）。
    - **此内存区域是唯一一个在JVM规范中没有规定OutOfMemoryError的区域。**
    
- JVM虚拟机栈
    - 线程私有内存，生命周期与线程相同。
    - 描述的是Java方法执行的内存模型，每创建一个方法的同时都会创建一个**栈帧**
    - **栈帧**用于存储方法
        - 局部变量表
        - 操作数栈
        - 动态链接
        - 方法出口信息
    - 如果线程申请的栈深度超出了JVM锁允许的最大深度，就会抛出StackOverflowError
    - 如果JVM可以动态扩展，如果扩展式无法申请到足够大的内存就会抛出OutOfMemoryError
- 本地方法栈
    - 执行Native方法，sun的HotSpot虚拟机直接把   JVM虚拟机栈和 本地方法栈合二为一。

- 直接内存，也称为对外内存：
    - 不属于JVM运行时内存管理范围之内，但是这部分内存也会被频繁使用，也是有可能会出现OOM现象。
    - 也是内存，肯定会收到本机内存大小的制约。
    
    

# 二 直接内存（堆外内存）和堆内存对比
- 直接内存的好处：避免了Java堆和Native函数库分配的堆外内存之间的来回复制数据

# 三 对象的创建
- 1 创建对象是通过new关键字来实现，对于JVM来说new关键字背后还有很多细节。当创建一个对象，例如：Object object = new Object()，它对应的字节码指令是new（对象数组和基本类型数组不是），当执行到new指令时，虚拟机会先检查对应的类是否被加载过，如果没有被加载，那么执行类加载的过程。
- 2 分配的方式
    - 指针碰撞：如果堆内存是整齐的，使用的内存和未使用的内存以分界点分开，那么为新生对象分配内存就是将分界点指针向空闲的内存那边挪动对象同等大小的位置就可以了。
    - 空闲列表：如果堆内存不是整齐的，已使用内存和空闲内存交错并存，那么虚拟机必须得维护一下列表记录哪些内存是正在使用的，哪些内存是未使用的，分配内存的时候需要找一块大于或者等于当前对象大小的内存空间，这种分配算法称为空闲列表。
    - 选择方式：是由java堆内存是否规整来决定的，而java堆是否规整又由gc回收期的回收方式来决定。
        - Serial，ParNew这种新生代收集器，**都是使用复制算法**，按顺序分配内存，都是使用的指针碰撞！
        - G1 Parallel Old 使用的是**标记整理算法**，也是使用的指针碰撞！
        - CMS 基于**标记清除算法**的收集器，通常否是采用空闲列表！
- 3 对象在内存中存储的布局
    - 对象头：包括两部分数据
        - 1 用于存储对象的自身的运行时数据：如 哈希码，GC分代年龄（也就是多少岁，一般Minor GC（年轻代GC）一次加一岁），锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，官方称为Mark Word。
        - 2 类型指针：即对象指向它的类元数据的指针，JVM通过这个指针来确定它是哪个类的对象。
        - 如果对象是一个java数组，那在对象头中还必须要存储**数组的长度信息**，因为JVM可以通过普通java对象的元数据信息确定java对象大小，
        但是从数组的元数据中却无法确定数组的大小。
    - 实例数据
    - 对象填充 
- 4 对象的访问定位，访问对象的方式：java程序是通过栈上的**对象引用reference**来操作堆上的数据，由于引用类型在JVM规范中只规定了一个指向对象的引用，
    **并没有定义这个引用应该通过何种方式来找到并且访问堆上的对象**
    - 1 句柄：也就是**到对象实例数据的指针**
        - 例如： A a = new A(); 这里的a会引用该对象句柄池的地址， 他是通过
            - 1 a引用到句柄地址
            - 2 再通过句柄池来找到堆中对象的实例数据
        - 如图
        ![Image](https://raw.githubusercontent.com/chenyunbin777/cyb_springboot_test/master/JVM/JVM%E5%9B%BE%E7%89%87/句柄引用.png)

    - 2 直接指针：就是a直接引用到堆中对象的实例，也就是a存储的是对象的地址
        - 如图
        ![Image](https://raw.githubusercontent.com/chenyunbin777/cyb_springboot_test/master/JVM/JVM%E5%9B%BE%E7%89%87/直接引用.png)

    - 两种访问对象的方式得优劣
        - 句柄访问
            - 优点：最大的好处就是对象引用reference中存储的是稳定的句柄的引用，在对象被移动（gc是对象被移动内存堆中的位置很正常）时只会改变句柄中的实例数据指针，
            而reference不用修改。
        - 直接指针
            - 优点：最大的好处就是**访问速度快**，它节省了一次指针定位的时间。由于对象访问在java中非常的频繁，因此这种开销积少成多之后也是一项非常可观的成本。
            - **sun 公司的 HotSpot虚拟机是使用的直接指针**，但是使用句柄访问也很常见。
            
            
