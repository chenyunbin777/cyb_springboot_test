# 一 判断对象是否存活的方法
## 引用计数法
- 引用计数算法（Reference Counting）是这样的：给对象添加一个引用计数器，每当一个地方引用它时，计数值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。
    - 使用该方法的语言：Python，游戏脚本领域使用的Squirrel语言
    - 优点：实现简单，判定效率高，大部分情况下是个不错的算法
    - 缺点：无法解决循环引用的问题，所有java并没有使用它来管理内存
    - 循环依赖实例
        - 实例A中有B的引用，实例B中有A的引用
         ```
            A A = new A()
            B B = new B()
            A.b = B;
            B.a = A; 
            A = null;
            B = null;
            System.gc();//这样来垃圾回收并不会回收掉A和B
         ```
    
## 可达性分析算法 GC Root
- 在主流的商用程序语言的主流实现中java，C#，都是通过可达性分析（Reachability Analysis）来判定对象是否存活。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连，则证明此对象不可用。
- 可以作为GC Root的对象：
    - JVM栈（栈帧中的本地变量表）中引用的对象
    - 方法区内类静态属性引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈中JNI（Native方法）引用的对象
# 二 Java中的引用对象的类型
- 强引用：通过new产生的对象，只要强引用还在，gc就不会回收掉被引用的对象
- 软引用（SoftReference类）：在系统将要发生内存溢出异常之前，将会把这些对象列入回收范围进行第二次回收。如果这次回收还是没有足够的内存才会抛出OOM。
- 弱引用（WeakReference类）：被弱引用关联的对象只能生存到下一次垃圾收集发生之前。无论是否有足够的内存都会被回收掉。
- 虚引用（PhantomReference类）：它是最弱的一种引用关系。一个对象是否有虚引用完全不会对其生存时间造成影响，也无法通过虚引用来获得一个对象实例。
为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知（这个例子在java编程思想并发编程中有用过）。
- 练习

# 三 对象的生存与死亡，这是个问题，嗯！
- 即使在可达性分析算法中不可达的对象，也有一次自我救赎的机会。要真正宣告一个对象死亡，还有经过以下过程：
    - 判断对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法或者该方法已经在之前被调用过一次，那么虚拟机将视其为没有必要执行，该对象即将被回收。
    - 如果对象有必要执行finalize()方法，在执行了该方法后，该对象可达（不可达依旧会被回收），则将其移出即将回收的集合。这是对象拯救自己的唯一方式。
    - **两次标记：1 判断没有与GC Roots相连之后进行一次标记  2 执行finalize()方法，之后进行第二次标记**
- **finalize()最多只会被系统自动调用一次** 在这一次的调用过程中，可以通过将自己的this指针赋值给某个类变量或者对象的成员变量来**拯救自己一次**，
但是当第二次在gc的时候就不会存活了，忘记finalize()这个方法！！！
    - 测试参考：/Users/chenyunbin/Documents/我的idea项目/cyb_springboot_test/src/main/java/com/cyb/codetest/JVM/FinalizeEscapeGCTest.java
 
 
# 四 回收方法区
- HotSpot虚拟机的永久代
- 永久代的gc只要回收两部分内容
    - 废弃常量：没有任何一个引用，引用常量池中的常量，那么就可以回收
        - String a = "abc";  没有任何的引用 引用了 "abc"时，"abc"就可以回收。
    - 无用的类：回收的条件比较苛刻
        - 1 该类所有的实例都被回收，java堆中不存在该类的任何实例
        - 2 加载该类的ClassLoader已经被回收
        - 3 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
        - 满足以上三个条件才有可能呗JVM回收掉

# 五 垃圾收集算法
## 标记-清除算法
- 标记出需要所有需要回收的对象，标记完成后统一回收所有被标记的对象。
    - 两次标记：1 判断没有与GC Roots相连之后进行一次标记  2 执行finalize()方法，之后进行第二次标记
    - 这是最基础的gc算法，是因为后续的gc算法都是基于这种思路并对其不足进行改制而得到，
    - 不足之处：
        - 1 效率问题：标记和清除两个过程的效率都不够高
        - 2 空间问题：标记清除之后会产生很多的不连续的内存碎片，碎片太多有可能会导致找不到足够的大小来存放一些较大的对象 而不得不产生新的一次的gc，影响效率。
 
## 复制算法
- 将内存划分为大小相等的两块，一块内存用完了，将存活的对象移动到另一块，循环往复。
- 不足：内存利用率太低，有一半的内存无法利用
- 优点：简单 效率高
- 重点来喽，也是考点！
    - 现在的商业JVM都采用复制算法来**回收新生代**，IBM公司的专门研究表明，新生代中的对象98%是 "朝生夕死" 的，所以并不需要1：1的比例来划分内存空间。
    - 实际上sun公司的HotSpot VM 一直使用的就是 Eden：SurvivorFrom：SurvivorTo = 8：1：1，跟IBM研究没有半毛钱关系。
        - 当Eden与Survivor内存满了之后进行gc，将存活的对象放入另一块SurvivorTo，然后回收Eden与Survivor。
        - 当SurvivorTo不足以存储剩下的存活的对象时，就通过**分配担保机制**进入 老年代。
        
## 标记-整理算法
- 老年代的收集算法
    - 原因：复制收集算法在对象存活率较高的时候就要进行多次的复制操作，效率会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以老年代不能使用这种算法。
- 老年代的特点就是基本不会被回收    
- 根据老年代的特点，有人提出了另外一种标记-整理算法。标记过程和标记-清除算法一致，但后续步骤不是直接对可回收对象进行清理，而是让存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

## 分代收集算法
- 当前商业虚拟机的垃圾收集都采用分代收集算法，这种算法没什么新的思想，只是根据对象存活周期的不同将内存划分为几块。
一般是把Java堆分为新生代和老年代。在新生代使用复制算法，而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清理或标记-整理的算法来进行回收。

 
# 六 HotSpot的算法实现
- 枚举根节点
    - 从可达性分析 GC Roots找引用链为例，可作为GC Roots的节点主要是全局性的引用（如类静态变量，常量）与执行上下文（栈帧中的本地变量表）中。
    现在很多引用仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。
        - 在可达性分析的过程中不可以出现对象引用关系还在不断变化的情况，这一点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿Java的所有的线程的其中一个重要原因
        - Stop The World：sun将这件事称为 Stop The World 简称STW。即使是号称（几乎）不会发生停顿的CMS，枚举根节点也是要停顿的。
    - 目前主流JVM都是使用准确式GC:
        -**就是让JVM知道内存中某位置数据的类型什么**。比如当前内存位置中的数据究竟是一个整型变量还是一个引用类型。这样JVM可以很快确定所有引用类型的位置，从而更有针对性的进行GC roots枚举。
    - HotSpot是利用OopMap来实现准确式GC的。当类加载完成后，HotSpot 就将对象内存布局之中什么偏移量上数值是一个什么样的类型的数据这些信息存放到 OopMap 中；
        - 在 HotSpot 的 JIT 编译过程中，同样会插入相关指令来标明哪些位置存放的是对象引用等，这样在 GC 发生时，HotSpot 就可以直接扫描 OopMap 来获取对象引用的存储位置，从而进行 GC Roots 枚举。
        
- 安全点
    - HotSpot只在特定的位置记录了OopMap，这些位置就叫做安全点（Safepoint），也就是说，程序并不能在任意地方都可以停下来进行GC，只有到达安全点时才能暂停进行GC。
    - 安全点的位置：
        - (1) 循环的末尾 (防止大循环的时候一直不进入Safepoint，而其他线程在等待它进入Safepoint)
        - (2) 方法返回前
        - (3) 调用方法的call之后
        - (4) 抛出异常的位置
    - 安全点暂停线程运行的手段有两种
        - 抢先式中断
            - 不需要线程的执行代码主动配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上再暂停。**不过现在的虚拟机几乎没有采用此算法的**。
        - 主动式中断
            - GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时去主动轮询查询此标志，发现中断标志为真时就中断自己挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。
            
            
- HotSpot安全区域
    - 安全区域是指在一段代码片段内，引用关系不会发生变化，在这段区域内，任意地方开始GC都是安全的。 可以看做是扩展版的安全点
    - 产生原因
        - 安全点机制保证了程序执行时进入GC的问题。**但是对于非执行态下，如线程Sleep或者Block下，由于此时程序（线程）无法响应JVM的中断请求**，JVM也不太可能一直等待线程重新获取时间片，此时就需要安全区域(Safe Region)了。
    - 运行机理
        - 在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region。当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了；
        当线程要离开Safe Region时，如果整个GC完成，那线程可继续执行，否则它必须等待直到收到可以安全离开Safe Region的信号为止
      

# 七 垃圾收集器
![Image](https://raw.githubusercontent.com/chenyunbin777/cyb_springboot_test/master/JVM/JVM%E5%9B%BE%E7%89%87/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png)
HotSpot的GC

如果两个收集器之间有连线说明他们可以搭配使用
## 年轻代收集器
- Serial：单线程收集器
- ParNew：多线程收集器
- Parallel Scavenge：并行的多线程收集器，复制算法

## 老年代收集器
- Serial Old
- Parallel Old
- CMS：Concurrent Mark Sweep 并发标记清除
https://www.jianshu.com/p/86e358afdf17
    - 目标：获取最短回收停顿时间 
    
    - 适用：B/S系统的服务端上， 基于“标记-清除”
    
    - 初始标记 （CMS initial mark）  **需要STW**
        - 标记一下GC Roots能**直接**关联的对象，速度很快
    - 并发标记 (CMS concurrent mark)
        - 就是进行GC Roots的向下追踪能够关联到的所有对象（耗时比较长）
        - 从“初始标记”阶段标记的对象开始找出所有存活的对象;
        - 与用户线程一起运行
    - 重新标记(CMS remark)          **需要STW**
        - 在并发期间 用户程序继续运行而导致的标记产生变动的那一部分对象的标记记录
        - STW的时间比初始标记长，远比并发标记短
    - 并发清除(CMS concurrent sweep)（耗时比较长）
        - 与用户线程一起运行
    - 缺点
        - CMS收集器对CPU资源非常敏感
        - CMS收集器无法收集浮动垃圾：在并发清除期间产生，已近过了标记的阶段，所以无法在这次GC回收掉。
        - 收集结束产生大量空间碎片
    - 内存碎片问题的解决
        - 参数 -XX:CMSFullGCsBeforeCompaction=n 意思是说在上一次CMS并发GC执行过后，到底还要再执行多少次full GC才会做压缩。默认是0，也就是在默认配置下每次CMS GC顶不住了而要转入full GC的时候都会做压缩。
        
        - **concurrent mode failure**：这个异常发生原因是：CMS运行期间预留的内存无法满足程序需要，就会出现一次。
            - 执行CMS GC的过程中，**同时业务线程也在运行**，当年轻带空间满了，执行ygc时，需要将存活的对象放入到老年代，而此时老年代空间不足，这时产生了这个问题。
            - **这时会启动备用预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样STW时间会很长。。。**
        - 设置cms触发时机有两个参数
            - -XX:+UseCMSInitiatingOccupancyOnly
            - -XX:CMSInitiatingOccupancyFraction=70
            - -XX:CMSInitiatingOccupancyFraction=70 是指设定CMS在对内存占用率达到70%的时候开始GC。
              -XX:+UseCMSInitiatingOccupancyOnly如果不指定, 只是用设定的回收阈值CMSInitiatingOccupancyFraction,则JVM仅在第一次使用设定值,后续则自动调整会导致上面的那个参数不起作用
              
           - 为什么要有这两个参数？
                - 由于在垃圾收集阶段用户线程还需要运行，**那也就还需要预留有足够的内存空间给用户线程使用**，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。
                - gc线程正在标记存活对象，用户线程同时向老年代提升新的对象，清理工作还没有开始，old gen已经没有空间容纳更多对象了，这时候就会导致concurrent mode failure， 然后就会使用串行收集器回收老年代的垃圾，导致停顿的时间非常长。
                - CMSInitiatingOccupancyFraction参数要设置一个合理的值，
                    - 设置大了，会增加concurrent mode failure发生的频率，
                    - 设置的小了，又会增加CMS频率，所以要根据应用的运行情况来选取一个合理的值。
                    - 如果发现这两个参数设置大了会导致full gc，设置小了会导致频繁的CMS GC，说明你的老年代空间过小，应该增加老年代空间的大小了。
                  
        - **promotion failed** ： 在进行Minor GC时，Survivor Space放不下，对象只能放入老年代，而此时老年代也放不下造成的，多数是由于老年带有足够的空闲空间，但是由于碎片较多，新生代要转移到老年带的对象比较大,找不到一段连续区域存放这个对象导致的。
            - 简单说就是对象分配担保晋升到老年代失败。
            - 解决方法
                - 如果是因为内存碎片导致的大对象提升失败，cms需要进行空间整理压缩；
                - 如果是因为提升过快导致的，说明Survivor 空闲空间不足，那么可以尝试调大 Survivor；
                - 如果是因为老年代空间不够导致的，尝试将CMS触发的阈值调低。
             
                                 

- G1：既可以回收新生代又可以回收老年代，面向服务端应用的GC
    - 1 并行与并发：充分利用多CPU，多核环境的下的硬件优势来缩短STW的时间，部分其他GC原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发 的方式让Java程序继续执行，
    - 2 分代收集：保留分代收集概念，可以不需要其他GC配合来管理整个堆，采用不同方式去管理新创建的对象和已经存活了一段时间，熬过多次GC的旧对象以获取更好的手机效果。
    - 3 空间整合：G1整体来看是基于：**标记-整理**，但是局部两个Region之间看是：**复制算法**实现的。
        - 不会产生空间碎片，内存规整。有利于程序长时间运行，分配大对象是不会因为没有足够的空间而产生一次GC
    - 4 可预测的停顿：G1不止追求低停顿，还能建立可预测的停顿时间模型， M毫秒，gc时间不超过N毫秒，几乎是实时Java gc的特征了。
    
    - G1 将整个堆划分为很多大小相等的独立区域 region ,虽然保留新生代和老年代的概念，但是不在物理隔离，他们都是一部分Region的集合（不需要连续的Region）
    - 跟踪各个Region里的垃圾堆积的价值大小（回收所获得的空间大小以及回收的所需时间的经验值），在后台**维护一个优先列表**，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-Firest名称的由来）
        Region划分内存空间预计有优先级的区域回收方式，保证了G1 GC在有限时间可以获取尽可能高的收集效率
    - Region之间不是孤立的，一个对象分配在某个Region中，不止能被当前Region引用 而是可以与整个Java堆的任意对象发生引用关系。
        - 那可达性分析时是否要扫码整个堆？ 这个问题不止在G1中有，只是更加突出而已。 gc时 **回收新生代时也不得不扫码老年代**。那么Minor GC效率会下降很多。
        - 为了避免全堆扫描，使用Remembered Set. 在各个Region中会把相关引用信息记录到被引用对象的Remembered Set中
        
    - 回收过程：
        - 1 初始标记：仅仅标记gc Roots 可以直接关联到的对象， STW 但是时空很短
        - 2 并发标记：从GC Roots开始对堆中对象开始可达性分析，找出存活对象，与用户线程并行，时间较长
        - 3 最终标记：修正并发标记期间的因用户线程并行运作而导致的标记的变动 STW，但是可以并行执行
        - 4 筛选回收：根据优先级列表中的顺序来回收价值最大的垃圾。 （回收价值 成本进行排序）


#内存分配与回收策略
-（1）优先 Eden 分配
-（2）大对象直接进入老年代
-（3）长期存活的对象进入老年代：用一个Age计数器来记录每个对象的年龄：如果对象在Eden区出生并经过第一次MinorGC后仍然存活，并且能够被Survivor容纳的话，Age++;
    - -XX:MaxTenuringThreshold=77 设置年龄阈值
-（4）动态对象年龄判断：年轻代中 ToSurvivor空间有相同年年龄的对象大于一半ToSurvivor空间，年龄大于或等于这个年龄的对象进入老年代
-（5）空间分配担保：在发生Minor GC前，JVM会检查老年代最大的可用连续空间是否大于新生代所有对象总空间，如果成立，Minor GC可以确保是安全的。
    - HandlePromotionFailure设置值 JDK6之后就不用了
    - JDK6之后规则变为：只要老年代的连续空间大于新生代对象的总大小或者历次晋升到老年代的对象的平均大小就进行MinorGC，否则FullGC。

