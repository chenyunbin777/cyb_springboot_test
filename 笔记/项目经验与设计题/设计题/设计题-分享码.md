# 1 高可用性与伸缩性
- 采用分布式集群的方式，通过负载均衡机制，让每个机器的请求不要过量的高以至于造成不可用的情况
- 如果某台机器不可用了，我们也可以通过**容错机制** **无感知**的下掉这台机器。
    - 容错机制：故障降级
        - 1 failover：请求失败时，重试其他机器
        - 2 fastfail：快速失败，返回异常信息
        - 3 failsafe：出现异常直接忽略
        - 4 failback：请求失败记录在失败队列，采用定时线程池重试执行。采用异步的最终一致性解决方案。
        - **5 调用Mock数据： 某些接口，直接返回null，或者不处理。**
    - 心跳机制：一般我们的服务都会有一个注册中心，都会心跳的检测我们集群中的某台server是否没有感知。
    如果没有，就从我们的注册中心zk列表中删除其信息，这样请求就不会请求到这台server。
- 限流，服务降级：通过配置中心，主动下掉对应不重要的服务，这就是 微服务解耦的很重要的原因
    - 静态界面：物品界面都是缓存在前端或者CDN上的
    - 不重要的服务不可用-如： 退款，一些不重要的活动，评价，


# 2 高并发下读取数据的方式-分布式缓存
- 1 分布式缓存：Redis分布式缓存，可以通过**一致性hash算法**，并且增加虚拟节点来保证我们的分布式集群的高可用性。
- 2 缓存雪崩：大量redis缓存同一时间失效而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。
从而形成一系列连锁反应，造成整个系统崩溃。
    - 解决办法
    - 1 设置过期时间的时候，将过期时间+一个随机值，不要在同一时间过期大量数据

- 3 缓存穿透：缓存中没有数据，数据库也没有数据，那么大量的请求都在mysql数据库中，容易造成mysql的异常
    - 解决办法
    - 1 可以采用**布隆过滤器**来确定某些数据是否存在。如果不存在过滤器直接返回
    - 2 直接在redis中缓存null值，但它的过期时间会很短，最长不超过五分钟
  
- 4 缓存击穿，也就是一个热点数据的解决问题
  - **是指一个key非常热点**，在不停的扛着大并发，大并发集中对这一个点进行访问，
  当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据。
  - 解决办法：
    - 1 每一个key请求一次，我们都对这个key的过期时间进行一定的增量时间，约热点的数据过期时间越长。
    - 2 我们还可以在所有的server上设置对应的**本地缓存**，不请求redis，可以更快的缓存数据
 
- 5 **缓存与mysql的双写一致性**：我们可以通过
    - 1 先写入数据库再删除redis
        - 1 先写入或更新数据库数据之后，删除redis缓存
        - 2 下次请求缓存时发现没有缓存，在从数据库加载数据到我们的redis中。
    - 2 先删除缓存，在写入or更新数据库
    - 3 同步一致性：直接加锁，但是效率太低
    - 当然每个办法都有对应的弊端，没有办法是十全十美的，除非你需要放弃一些其他的。
    - 需要根据业务需求来确定
    
# 3 MQ来处理异步与削峰
- 客户的请求都放在MQ中，异步处理
- 异步双写or 同步双写，来保证MQ集群的数据一致性 与 高可用性 


# 4 server高并发数据处理
- **线程池**来增加我们的并发处理能力

 
# 5 mysql数据表设计
- 分库：如果涉及到数据库性能的话考虑根据不同的业务来进行数据分库
    - 1 垂直分库：是指按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上，
    它的核心理念是专库专用。
        - 解决业务层面的耦合，业务清晰
          能对不同业务的数据进行分级管理、维护、监控、扩展等
          高并发场景下，垂直分库一定程度的提升IO、数据库连接数、降低单机硬件资源的瓶颈
    - 2 水平分库：水平分库是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上。
        - 解决了单库大数据，高并发的性能瓶颈。
          提高了系统的稳定性及可用性。

    - 跨库join问题：我们采用将多库的数据获取之后，在业务逻辑中进行合并处理，而不使用join
- 分表：如果涉及到单表大数据查询，考虑分表来处理
    - 分表策略：
    - 水平拆分
        - 1 根据业务需求来分表，我们通过shop 002166 后三位 mod 64 分64张表
        - 2 根据主键id的范围来分表：1~1w一张 1w~2w一张、、、
        - 3 根据时间范围分表：比如 按月，年，周等。也可以把相对于说的热点数据，单独抽离出来
        - 4 或者根据唯一主键进行分表，id mod 分表数量
    - 垂直分表定义：将一个表按照字段分成多表，每个表存储其中一部分字段。
        - 1 根据不同的字段来进行分表， id name  age 我们将id name经常查询的分裂出去，id age分一张表
        - 2 将访问频次低的商品描述信息单独存放在一张表中，访问频次较高的商品基本信息单独放在一张表中。
    这样查询出去也就不涉及其他不相干字段的过滤手段了，查询效率更高
        - 1.为了避免IO争抢并减少锁表的几率，查看详情的用户与商品信息浏览互不影响
          2.充分发挥热门数据的操作效率，商品信息的操作的高效率不会被商品描述的低效率所拖累。
    

    