# 2PC两阶段提交：强一致性提交
- 阶段1 投票 事务询问是否可以提交事务
    - 1 协调者向所有的参与者发送事务内容，询问是否可以提交
    - 2 各个参与者想协调者反馈，是否可以执行事务
- 阶段2 执行
    - 1 如果反馈都是Yes那么，协调者回想所有的参与者发送commmit请求
    - 2 协调者提交事务，完成后释放事务执行期间占用的资源
    - 3 想协调者反馈，接收到所有的参与者的ack消息后，协调者自身提交事务
    
- 中断事务
    - 如果协调者无法收到**所有的参与者**的ack ok的话会发起中断事务请求
    - 1 发送回滚信息给参与者
    - 2 参与者回滚事务
    - 3 参与者发送回滚完成ack
    - 4 协调者收到所有的参与者的ack之后，中断事务
    
- 缺点
    - 1 同步阻塞：所有事物操作逻辑都是阻塞状态
    - 2 单点问题：**协调者**如果出现问题，其他参与者都是会在处于一个锁定事务资源的状态中。
    - 3 数据不一致：如果  协调者发送完commit请求后，宕机了，所有收到commit的参与者都会提交事务，
    那么没有收到commit请求的参与者无法提交事务
    - 4 脑裂：出现网络分区 
# 3PC
- 阶段1 投票 事务询问是否可以提交事务

- 阶段2 预提交：先执行实务操作，不会真实提交事务。。。

- 阶段3 最终提交： 协调者想所有的参与者发送commit消息，真正的去提交事务

- 问题：如果协调者出问题，协调者与参与者出现网络故障
    - **参与者会在超时之后，继续提交事务**
    
- 优点：降低了参与者的阻塞范围，并且能在出现单点故障之后继续达成一致。
- 缺点：参与者接收到到precommit之后，出现网络分区，参与者依然会进行提交，这必然会出现数据不一致
