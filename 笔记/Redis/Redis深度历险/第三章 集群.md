# 3.1 主从同步
- Redis可以使用主从同步，从从同步。
  - 1 第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到**内存buffer**，
    - 这里的buffer是一个**定长的环形数组**，如果满了会从头部开始覆盖前面的内容
    - **要设置一个合理的buffer大小，避免主从同步中buffer中增量数据的覆盖，导致不断的重新请求主从同步形成快照同步死循环**。
  - 2 待完成后将rdb文件全量同步到复制节点，
  - 3 复制节点接受完成后将rdb镜像加载到内存。
  - 4 加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。
  
  

# 3.2 高可用-哨兵Sentinel
- 1 类似于zk之于dubbo，都是类似于注册中心的功能。
    - 客户端通过集群Sentinel 来找到对应的master节点。
    - 如果master挂掉之后，Sentinel会重新选举一个slave作为master
    - 如果挂掉的master又好了会重新作为salve挂载到新master上
    
- 2 master挂掉之后可能会有在同步中的salve没有收到全部的同步消息，这部分消息数据就丢失了。
Sentinel无法保证不丢失数据，但是可以减少数据丢失。
    - min-slaves-to-write 1   主节点必须至少有一个从节点在进行正常的复制，否则就停止对外写服务，丧失可用性
    - min-salves-max-lag 10   10s内没有收到从节点的反馈就意味的同步不正常。
    
    
# 3.4 Redis Cluster
- 不支持事务
- 1 集群中所有的节点共享16384个槽位 slot。
    - 在redis集群内部，采用slot槽位的逻辑管理方式， 集群内部共有16384(2的14次方)个Slot，集群内每个Redis Instance负责其中一部分的Slot的读写。
    一个Key到底属于哪个Slot，由分片算法：
        - crc16(key) % 16384决定。也正是通过此分片算法，将不同的key以相对均匀的方式分配到不同的slot上。
- 2 跳转：查询节点不存在的key时，会让client重新定位key的Redis实例节点。

- 3 迁移：使用工具redis-trib
    - migrate指令同步迁移：从源节点获取内容-》存到目标节点-》源节点删除内容
    - 迁移过程中访问数据：
        - 1 旧节点中是否存在，不存在重定向到新节点执行一个**ASKING指令**（表示需要当成自己的槽位来处理，），然后执行对应的redis命令。
    
- 4 容错
    - 集群中可以为每一个master配置若干个salve，当master挂掉，升级slave为master之后，该新master没有salve会导致集群不可用
    - cluster-require-full-coverage yes （redis.conf）允许集群中部分节点不可用，其他节点还可以对外提供访问。
    
    
- 5 网络抖动
    - 集群节点超过这个时间不可以被访问，我们就认为该节点有故障，需要主从切换
        - cluster-node-timeout 15000（ms）
        
- 6 集群广播
    - 通过Gossip协议集群广播的方式告诉集群中其他的节点，某一个节点失联了，然后集群使该几点进行主从切换。