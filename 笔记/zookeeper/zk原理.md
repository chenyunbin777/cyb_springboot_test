# 脑裂问题
- 1 follower与leadre之间的通信是通过心跳检测实现的，follower会注册Watcher在leader中**创建的临时文件**。一旦zookeeper发现
leader有问题了，会改变临时节点，然后zk就会发通知给各个follower，follower再调用对应的回调handler。

- 2 **注意watch是一次性的，每次都需要重新注册**，并且客户端在会话异常结束时不会收到任何通知，而快速重连接时仍不影响接收通知。

- 3 如果leader1由于网络问题，follower监听不到leader的存在时，就是发生选举出一个新的leader2。那么这时候就有两个leader了。
之后leader1又恢复了通信的话，我们应该听谁的呢？
    - 答：听最新的leader 的，因为他是有**最新的事务id：ZXID**。就算是leader1不能用，也不影响leader2的使用。

- 4 zookeeper解决脑裂的方案：存在超过半数的机器才可以选举称为leader
    - 假设某个leader假死，其余的followers选举出了一个新的leader。
    这时，旧的leader复活并且仍然认为自己是leader，这个时候**它向其他followers发出写请求也是会被拒绝的**。
    因为每当新leader产生时，**会生成一个epoch标号(标识当前属于那个leader的统治时期)**，这个epoch是递增的，
    followers如果确认了新的leader存在，知道其epoch，就会拒绝epoch小于现任leader epoch的所有请求。
    那有没有follower不知道新的leader存在呢，有可能，但肯定不是大多数，否则新leader无法产生。
    Zookeeper的写也遵循quorum机制，因此，**得不到大多数支持的写是无效的**，旧leader即使各种认为自己是leader，依然没有什么作用。



#Zookeeper 集群节点为什么要部署成奇数
至于为什么最好为奇数个节点？这样是为了以最大容错服务器个数的条件下，能节省资源。
比如，最大容错为2的情况下，对应的zookeeper服务数，奇数为5，而偶数为6，也就是6个zookeeper服务的情况下最多能宕掉2个服务，
所以从节约资源的角度看，没必要部署6（偶数）个zookeeper服务节点。



# Leader选举
##

- 选主算法中的zxid是从内存数据库中取的最新事务id，事务操作是分两阶段的（提出阶段和提交阶段），
    - 1) 提交阶段：leader生成提议并广播给followers , follower收到提议后先将事务写到本地事务日志，然后反馈ACK
    - 2）提交阶段：leader收到半数以上的ACK后，再广播commit消息，同时将事务操作应用到内存中。
    - 可见，选主只是选出了内存数据是最新的节点，仅仅靠这个是无法保证已经在leader服务器上提交的事务最终被所有服务器都提交。
比如leader发起提议P1,并收到半数以上follower关于P1的ACK后，在广播commit消息之前宕机了，
选举产生的新leader之前是follower，未收到关于P1的commit消息，内存中是没有P1的数据。
而**ZAB协议的设计是需要保证选主后，P1是需要应用到集群中的**。这块的逻辑是通过选主后的数据同步来弥补。 


# ZAB协议（Atomic Broadcast 原子广播协议）
- 作为其数据一致性核心的算法。，是
    - 1 崩溃可恢复的：当服务框架启动或者Leader崩溃，网络中断或者重启，我们会选举新的Leader，
    当超过半数follower与Leader数据同步完成之后（保证数据状态一致）。此时恢复完成，退出恢复模式。
    
    - 2 原子消息广播算法
        - 核心原理（数据同步机制）：leader将我们应用服务器的请求转换成一个事务Proposal，并且广播到集群中所有的Follower当中
    只要有超过半数（n/2+1）的Follower进行了正确的反馈之后，Leader会再次向所有的Follower分发Commit消息，要求
    其将前一个事务提交。
        - 基于TCP协议，可以保证消息发送与接收的顺序性。
        - 事务ID：ZXID，单调递增的唯一ID，在Leader广播事务之前会进行创建。
            - 64位的数字
            - 低32位，应用服务器没产生一次事务请求，就+1
            - 高32位代表Leader的周期编号，每选举一个Leader，会从其中找出其本地日志中最大的ZXID，取高32位然后就+1；重新选举之后，低32位清零
                - 保证了当前Leader不会以之前的Leader的ZXID，去提交与之前Leader ZXID 不同的事务请求的。
                - 如 Leader1提交了 ZXID1， 此时Leader1挂了，选举出Leader2，Leader2也不会使用ZXID1去提交新的事务
 
- 选举算法：Leader不可用，从其他Follower选举出 ZXID最大的机器作为Leader，他已经具有所有最新的事务提案。
    
```
# dubbo注册中心的地址
dubbo.registry.address=zookeeper://zk6.prod.souche:2181?backup=zk7.prod.souche:2181,zk8.prod.souche:2181,zk1.prod.souche:2181,zk4.prod.souche:2181,zk5.prod.souche:2181

```

# zookeeper分布式锁
- 独占锁：
    - 创建锁：在zk上创建一个临时节点/exclusive_lock/lock,会保证同时只有一个一台服务器能够创建成功
        - 其他没有获取的服务器会就需要到/exclusive_lock上注册一个子节点变更的Watcher（时间通知机制）。
    - 释放锁：
        - 1 执行完正常业务之后 
        - 2 创建临时节点的服务器发生宕机
        
- 共享锁
    - 创建锁：只能读不能写、写完只能在共享锁结束。 多个客户端请求共享锁都会创建一个**节点序号**
        - 读请求：先来的序列号小，如果前面序列号都是读请求，那么同步执行读操作
            - 如果前面序号有写请求，则需要等待
        - 写请求：如果自己是最小的序列号，则执行
        
    
# 应用场景
## 数据发布与订阅
- zk采用的时候推拉结合的方式
    - 应用服务器想zk注册自己需要关注的节点，一旦节点数据发生变更，zk会主动的向应用服务器发送Watcher时间通知
    应用服务器接受到这个消息之后，主动向zk拉取对应的最新的配置
    - 配置可以是
        -机器列表，运行时开关配置，数据库配置信息等
## 负载均衡
- 当服务器宕机，zookeeper因为没有检测到心跳，自动把该节点移除，并通知其他服务器，其他服务器得知该机器已宕机，
在分配连接时，不会分配到这台机器上，这点也是标题说的在负载均衡中用到zookeeper的原因

## 命名服务
- 使用分布式全局唯一ID的分配机制，如 type-job-0000000003，可以来唯一标识一个API接口

## 分布式协调/通知
- zk中特有的Watcher注册与异步通知机制，能够很好的实现分布式系统下的不同机器的，不同系统的协调与通知
    - 实现对数据变更 的**实时处理**
    - 实现的方式：所有的应用服务器都会在zk上同一个数据节点注册一个监听器Watcher，
    如果数据发生变动之后，zk会主动告知所有监听的服务器有数据变更，他们就会主动拉取这种变更。
    
## 任务热备份（Mysql），还是作为通知的角色

-  Running机器为主机器，Standby为子机器 ，所有机器都会在mysql上创建一个临时节点，按顺序号id来排列，
server1 server2....等，  id最小的为Running运行主机。
- 所有Standby机器都需要注册一个"子节点列表变更"的Watcher监听，如果Running机器宕机与zk断开连接，
其他Standby收到这个通知后，会进入下一轮Running机器选举。
- 总结：还是 "小序号优先"的选举规则，主机宕机，会选取最小顺序号的机器来代替主机。
    - 至少使用两台机器

## 冷备份
- 采用多进程扫描的方式，而不是多机器实时进行数据备份。降低了任务的协调的实时性，但是节省了机器资源。

## 一种通用的分布式系统机器间的通信方式

- 心跳检测
    - 基于zk的**临时节点**的特性，可以让不同的机器在zk的一个指定节点下创建临时节点，不同机器之间通过这个临时节点来判断
    对应的机器是否存活。
    - 好处：被检测系统和检测系统不需要直接关联，大大减少了系统的耦合。
- 工作汇报进度：都是运用临时节点的特性。
- 系统调度

- 总结：zk实现分布式系统之间的通信
    - 节省大量底层网络通信的协议设计上的重复工作
    - 主要是减低系统之间的耦合程度， 非常灵活的实现异构系统之间灵活的通信。

- 集群管理：也就是监控集群中所有机器的删减，数据的变更，对所有机器进行同步
    - 还是使用临时节点和Watcher监控通知的机制。
    - 所有机器创建临时节点在zk上，如果某个机器数据变更了或者是zk上的节点列表发生变更，通过Watcher监控会通知到所有的机器数据的变更。
    - 在zk上创建临时节点，一旦server与zk之间会话失效，临时节点也会自动删除。


# Master选举
- 还是最先创建临时节点的机器为master，其他机器创建一个Watcher监听，如果Master挂了，重新进行Master选举（ZXID）

#分布式队列
- FIFO：
    - 1 所有Server在zk上创建一个临时节点，按序列号的方式排列
    - 2 每个机器在向比自己序列号小的最后一个节点注册一个Watcher监听，收到Watcher通知后，开始执行。
- Barrier：分布式屏障
    - 设置/queue_barrier节点 的值 n = 某个数，如10，当队列的数量达到10的时候一并的全部执行。    







- zk原
- mysql什么时候不会用到索引
- redis 持久化方式
- spring的原理理
    - IOC AOP