# IO多路复用
- https://www.bilibili.com/video/BV1qJ411w7du?spm_id_from=333.337.search-card.all.click&vd_source=bfdcde7113ef62c44f0c7098f5d57a62 

- linux系统中一切都是文件，每一个网路连接在linux内核中都是以文件描述符（fd） 的方式存在。

- select：bitmap中或保存所有的需要被执行的fd集合，在源码中会whlie(true)检查fd集合rset（就是一个bitmap）中是否存在数据，如果存在
会将数据从**用户态** 拷贝到 **内核态**执行，需要有**用户态内核态的切换*，因为内核态处理的更有效率。
    - 1 如果rset没有数据时会一直阻塞在select函数中。
    - 2 如果有数据，那么会将rset置位为1，然后交给内核态处理判断哪一个fd有数据，判断完之后select函数返回。
        - 然后遍历fd的集合，找到被置位的fd数据进行处理。
        
    - 缺点：
        - bitmap集合最大大小是1024，是有上限的
        - rset集合不会重用，每次的while(true)都会重置rset
        - 会有用户态内核态的切换,会有开销
        - 在select返回时会再次变量rset来判断哪些fd是有数据的。
    
    
- poll

- 3 epoll: 使用场景Redis， ngnix， java nio linux操作系统下
    - （1）首先在内核中创建了
        - 1 红黑树（保存在内核cache中，）：用于保存所有的fd，查询效率相比数组或者bitmap更高。用户线程也不必要每次都把所有的fd拷贝给内核态
            只需要增量的给内核态就好。如果红黑树中不存在就插入其中。
        - 2 就绪列表：用于保存所有的就绪事件（就绪fd），内核直接把就绪的fd返回给用户态即可，不需要每次都拷贝所有的
            fd给用户态，再去让用户态判断一遍。
            
        - 3 回调函数，告诉内核，如果这个fd的中断到了，就把它放到准备就绪list链表里。所以，当一个fd（例如socket）上有数据到了，
        内核在把设备（例如网卡）上的数据copy到内核中后就来把fd（socket）插入到准备就绪list链表里了。
            如此，一颗红黑树，一张准备就绪fd链表，少量的内核cache，就帮我们解决了大并发下的fd（socket）处理问题。
    - 事件触发方式 
        - LT水平触发：只要事件没有处理完毕，每一次epoll_wait都触发该事件， select poll epoll模式都是这个，但是epoll支持边缘触发优化。
        - ET边沿触发：无论事件是否处理完毕，仅触发一次
        
，也可以叫时间监听模型：epoll改进了select 突破了1024个连接，扫描使用了红黑树 nio。




