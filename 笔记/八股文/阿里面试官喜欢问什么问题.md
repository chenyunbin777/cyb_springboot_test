Java面试
阿里的面试官都喜欢问哪些问题？
首先我们需要明白一个事实，招聘的一个很关键的因素是在给自己找未来的同事，同级别下要找比自己优秀的人，面试是一个双向选择的过程，也是一个将心比心去沟通的过程。

就像我们有的人感觉自己很牛逼，但是拿不到 offer，而其他的人菜的一笔，却可以拿到 offer，我们称之为玄学 offer，遇到这种情况大家也不要感觉到有什么不可描述的心情，一切随缘即可！

一、开场白

◎ 简单的介绍一下自己的工作经历与职责，在校或者工作中主要的工作内容，主要负责的内容；（你的信息一清二白的写在简历上，这个主要为了缓解面试者的压力）

◎ 介绍下自己最满意的，有技术亮点的项目或平台，重点介绍下自己负责那部分的技术细节；（主要考察应聘者对自己做过的事情是否有清晰的描述，判断做的事情的复杂度）

二、Java 多线程相关

◎ 线程池的原理，为什么要创建线程池？创建线程池的方式；

◎ 线程的生命周期，什么时候会出现僵死进程；

◎ 说说线程安全问题，什么实现线程安全，如何实现线程安全；

◎ 创建线程池有哪几个核心参数？ 如何合理配置线程池的大小？

◎ volatile、ThreadLocal 的使用场景和原理；

◎ ThreadLocal 什么时候会出现 OOM 的情况？为什么？

◎ synchronized、volatile 区别、synchronized 锁粒度、模拟死锁场景、原子性与可见性；

# 三、JVM 相关

## JVM 内存模型，GC 机制和原理；

## GC 分哪两种，Minor GC 和 Full GC 有什么区别？什么时候会触发 Full GC？分别采用什么算法？

## JVM 里的有几种 classloader，为什么会有多种？
- 启动类加载器
    - 使用c++编写是虚拟机的一部分，其他都是使用的java语言实现，独立于jvm外部，并且全部都继承抽象类
    java.lang.ClassLoader
    - /Users/chenyunbin/Documents/jdk1.8.0_231.jdk/Contents/Home/jre/lib 下
- 扩展类加载器
    -   /Users/chenyunbin/Documents/jdk1.8.0_231.jdk/Contents/Home/jre/lib/ext 下
- 应用程序类加载器（系统类加载器）
    - 可以加载自定义的类加载器，如果没有则是默认使用systemClassLoader来加载类。
    
- 自定义类加载器

## 什么是双亲委派机制？介绍一些运作过程，双亲委派模型的好处；

- 如果一个类收到了类加载的请求，他不会尝试去加载，而是将这个请求委派给父类加载器去完成，一直委派给最顶层的启动类加载器；
只有到父类加载器无法加载这个类的时候，才会交给子类去加载。

- 这样做的好处是，
    - 1 方式一个类经过不同的类加载器进行加载而生成不同的类。就比如说 你自己在代码中创建了一个java.lang.Object,他存放在rt.jar之中，无论哪个类加载器加载这个类，最终都是委派给最顶层的 **启动类加载器进行加载**，因此Object类在程序的各种类加载器环境中都是同一个类
    - 2 保证了java运行的稳定性：如果自定义的java.lang.Object也可以被加载，那系统中会出现多个Object类，会一派混乱。




## 什么情况下我们需要破坏双亲委派模型；
答：
1 
2 JNID
3 在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构。  热加载。。热部署

双亲委派模型的破坏 
双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前–即JDK1.2发布之前。由于双亲委派模型是在JDK1.2之后才被引入的，而类加载器和抽象类java.lang.ClassLoader则是JDK1.0时候就已经存在，面对已经存在 的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2之后的java.lang.ClassLoader添加了一个新的proceted方法findClass()，在此之前，用户去继承java.lang.ClassLoader的唯一目的就是重写loadClass()方法，因为虚拟在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。JDK1.2之后已不再提倡用户再去覆盖loadClass()方法，应当把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里，如果父类加载器加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派模型的。 
双亲委派模型的第二次“被破坏”是这个模型自身的缺陷所导致的，双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的API。但是，如果基础类又要调用用户的代码，那该怎么办呢。 
这并非是不可能的事情，一个典型的例子便是JNDI服务，它的代码由启动类加载器去加载(在JDK1.3时放进rt.jar)，但JNDI的目的就是对资源进行集中管理和查找，它需要调用独立厂商实现部部署在应用程序的classpath下的JNDI接口提供者(SPI, Service Provider Interface)的代码，但启动类加载器不可能“认识”之些代码，该怎么办？ 
为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：线程上下文件类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。了有线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI,JDBC,JCE,JAXB和JBI等。 
双亲委派模型的第三次“被破坏”是由于用户对程序的动态性的追求导致的，例如OSGi的出现。在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构。


## 常见的 JVM 调优方法有哪些？可以具体到调整哪个参数，调成什么值？
- https://cloud.tencent.com/developer/article/1198524
- 对年轻代的Eden Survivor的比例进行配置
    - -XX:SurvivorRatio=8 ：表示设置2个Survivor区：1个Eden区的大小比值为2:8，这意味着Survivor区占整个年轻代的1/5，这个参数默认为8
    - 如果经常性的 SurvivorTo放不下YGC的剩余的对象时候，可以适当的调整比例

- 常用的CMS收集器： 设置回收阈值，需要根据程序的运行过程中的gc log来观察是否会用频繁的full gc 与 CMS gc
    - -XX:+UseConcMarkSweepGC 使用CMS收集器
    - -XX:CMSInitiatingOccupancyFraction=70 是指设定CMS在对内存占用率达到70%的时候开始GC。
    - -XX:+UseCMSInitiatingOccupancyOnly如果不指定, 只是用设定的回收阈值CMSInitiatingOccupancyFraction,则JVM仅在第一次使用设定值,后续则自动调整会导致上面的那个参数不起作用
                  
    - Concurrent Mode Failure 错误：因为CMS给用户线程在 并发回收期间的预留内存不够，导致了这个错误，会使用Serial Old收集器，收集效率会急剧下降。
        - 所以说需要合理的设置上边的阈值
    - Promotion Failed：分配担保时，老年代的连续内存不足以存放年轻代晋升的对象，所以导致了这个错误（老年代内存碎片过多）
        - 解决：需要对内存碎片进行整理
            - -XX:UseCMSConpactAtFullCollection：开关默认开启，再要Full GC之前对内存碎片进行整理，停顿时间会变长
            - -XX:CMSFullGCsBeforeCompaction：默认0 每次full GC都会整理碎片。
            - 也可以适当的调整Survivor大小

- -Xms20M：初始堆内存
- -Xmx20M：最大堆内存
    - 默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。
      因此服务器一般设置-Xms、-Xmx相等**以避免在每次GC 后调整堆的大小**。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。
  
- -Xss128k
    - 表示可以设置虚拟机栈的大小为128k
- -XX:PermSize=64M 指的是JVM初始非堆内存
- -XX:MaxPermSize=64M  指的是JVM最大非堆内存
- -XX:NewRatio=4：表示设置 年轻代（包括Eden和两个Survivor区）/老年代 的大小比值为1：4，这意味着年轻代占整个堆的1/5
    - Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。
    - -Xmn ：年轻代大小，Sun官方推荐配置为整个堆的3/8
- -Xmn20M：表示设置年轻代的大小为20M
- -XX:MaxTenuringThreshold=15：对象每Minor GC在Survivor区存活一次 age++，当到age = 15的时候，直接进入老年代。




# JVM 虚拟机内存划分、类加载器、垃圾收集算法、垃圾收集器、class 文件结构是如何解析的；
- 堆 栈 元空间（方法区） 程序计数器 堆外内存
- class 文件结构：
    - 1 魔数：前四个字节都是魔数，为0xCAFEBABE，可以用于判断是否是一个class文件。魔数的固定值是Java之父James Gosling制定的
    - 2 版本号：魔数之后的4个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version）
        - 我们将对应的16进制转化“00 00 00 34”成10进制之后得出 0 和 52 ，然后通过Oracle官网中查询序号52对应的主版本号为1.8，所以编译该文件的Java版本号为1.8.0。
    - 3 常量池：常量池中存储两类常量：字面量与符号引用
        - （1）字面量为代码中声明为Final的常量值
        - （2）符号引用如类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符
        - 常量池整体上分为两部分：常量池计数器以及常量池数据区
    - 4 访问标志：常量池结束之后的两个字节，描述该Class是类还是接口，以及是否被Public、Abstract、Final等修饰符修饰。
    - 5 当前类名：访问标志后的两个字节，描述的是当前类的全限定名。
        - 这两个字节保存的值为常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名。
    - 6 父类名称：当前类名后的两个字节，描述父类的全限定名，同上，保存的也是常量池中的索引值。
    - 7 接口信息：父类名称后为两字节的接口计数器，描述了该类或父类实现的接口数量。紧接着的n个字节是所有接口名称的字符串常量的索引值。
    - 8 字段表：字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的局部变量。   
    - 9 方法表:
# 四、Java 高级部分

◎ 红黑树的实现原理和应用场景；

##  NIO 是什么？适用于何种场景？
http://ifeve.com/overview/

- Channel，Buffer 和 Selector 构成了核心的API
- 非阻塞IO，面向缓冲区，选择器，io多路复用器
    - 轮询方式：Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。
    而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。
    - 也就是说去通道（pipe）读取的时候，如果没数据立即返回，不会等待数据。
    - io多路复用：
    - 而对于NIO，使用一个线程发送读取数据请求，没有得到响应之前，线程是空闲的，此时线程可以去执行别的任务，而不是像IO中那样只能等待响应完成。
- Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。



# Java9 比 Java8 改进了什么；

# HashMap 内部的数据结构是什么？底层是怎么实现的？（还可能会延伸考察 ConcurrentHashMap 与 HashMap、HashTable 等，考察对技术细节的深入了解程度）；
- 数组+链表+红黑树
    - 每个链表中保存的都是key hashCode相同的value
    - 一些关键的字段
        - 默认的填充因子：DEFAULT_LOAD_FACTOR = 0.75f
        - 默认的初始容量是16 DEFAULT_INITIAL_CAPACITY = 1 << 4
        - 最大容量:static final int MAXIMUM_CAPACITY = 1 << 30; 
        - 存储元素的数组，总是2的幂次倍 transient Node<k,v>[] table; 
        - 当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间
        - 当链表长度小于6时树转链表
        - 
- 为什么HashMap要限制table的长度为2的n次幂？
    - 根据 n-1 做与操作的取模运算。这里也能看出为什么HashMap要限制table的长度为2的n次幂，因为这样，
    n-1可以保证二进制展示形式是（以16为例）0000 0000 0000 0000 0000 0000 0000 1111。在做"与"操作时，
    就等同于截取hash二进制值得后四位数据作为下标。这里也可以看出"扰动函数"的重要性了，**如果高位不参与运算，
    那么高16位的hash特征几乎永远得不到展现**，发生hash碰撞的几率就会增大，从而影响性能。
- 为什么加载因子是0.75f?
    - 加载因子太大的话，也就是说需要尽可能的把HashMap表填满了才进行扩容，那这样会使得hash冲突的 概率增大，
    但是如果加载因子太小，那只用了很小一部分空间就要开始扩容，使得空间利用率很低。那怎 么办平衡hash碰撞和空间利用率这个问题，
    这就是问题的关键！！
- put的原理：
    - 1 table如果是null 进行初始化
    - 2 如果数组中不存在该元素就new  Node
    - 3 如果存在，判断当前数组table中的key是否与 要存入的key 相等。如果相等 那就覆盖成新的value
    - 4 如果不相等：判断是否是树结构，如果是，则保存在红黑树中
    - 5 如果不是树，则插入链表之中；之后再判断链表的长度是否超过8，如果超过则将链表转换成红黑树
    - 最后 判断是否超过最大阈值，超过则扩容：
    ```
  size（当前容量）>initailCapacity*loadFactor  则进行扩容
  
  if (++size > threshold) 
          resize();
    ```
# Hashtable
- 继承自Dictionary类
- 方法都是由synchronized synchronized修饰，所以是线程安全的，但效率不高

# ConcurrentHashMap
- 线程安全的Map，内部通过synchronized + 分段式锁来实现的（jdk1.7） 
    - jdk1.8通过：JDK1.8的实现已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，
    并发控制使用Synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本
- 

## 说说反射的用途及实现，反射是不是很慢，我们在项目中是否要避免使用反射；
- 反射：
    - 它允许运行中的 Java 程序获取自身的信息，并且可以操作类和对象的内部属性。
    - 程序中一般的对象类型都是在编译期就确定下来的，而Java 反射机制可以动态的创建对象并调用其属性
    - 反射的核心：是 JVM 在运行时 才动态加载的类或调用方法或属性，他不需要事先（写代码的时候或编译期）知道运行对象是谁。
- 取消private的封装效果



## 说说自定义注解的场景及实现；
- 我们可以通过反射 来获取指定的(类或者方法)注解，来实现一些（对类或者方的）扩展功能



◎ List 和 Map 区别，Arraylist 与 LinkedList 区别，ArrayList 与 Vector 区别；

#五、Spring 相关

## Spring AOP 的实现原理和场景？
- 通过动态代理实现，有两种方式 Java原生（只能代理接口），cglib（可以代理类）。
- 当你需要在某一个功能的前后增加一些新的扩展的时候，可以使用SpringAOP

## Spring bean 的作用域和生命周期；
- singleton 单例
- prototype 多例，每次使用都产生一个新的实例
- |request| 为每个 HTTP 请求生成一个实例 |
- |session| 同一个 HTTP session 使用一个实例，不同 session 使用不同实例 |


## Spring Boot 比 Spring 做了哪些改进？ Spring 5 比 Spring4 做了哪些改进；
https://www.cnblogs.com/xueSpring/p/8024709.html
- Spring boot 优点：
    - Spring Boot配置更简单，不需要那么多配置文件的支持，大部分功能使用提供的注解都可以实现
    - 部署更简单，可以直接使用自身提供的BootStrap来直接运行，不需要外部容器的支持
    - Spring Boot属于微服务的框架
    - 重点是简化我们的开发。提升开发效率
- 改进
    - 1. 基准升级： 支持jdk8，以前的 JDK 和 JavaEE 版本不再支持
    - 2. 兼容 JDK9 运行时
    - 3. 使用 JDK8 特性
        - Spring 接口中的默认方法
        - 基于 Java8 反射增强的内部代码改进
        - 在框架代码中使用函数式编程 - lambda表达式 和 stream流
    - 4. 响应式编程支持
        - 响应式编程提供了另一种编程风格，专注于构建对事件做出响应的应用程序
        - SpringFramework5 包含响应流（定义响应性API的语言中立尝试）和 Reactor（由Spring Pivotal团队提供的 Reactive Stream 的Java实现）， 以用于其自身的用途以及其许多核心API。
    - 5. 函数式web框架
    - 6. Kotlin支持
        - Kotlin 是一种静态类型的JVM语言，它让代码具有表现力，简洁性和可读性。 Spring5.0 对 Kotlin 有很好的支持。
## 如何自定义一个 Spring Boot Starter？
https://cloud.tencent.com/developer/article/1420599

## Spring IOC 是什么？优点是什么？
- 控制翻转：将bean交给spring管理，不需要自己来new，销毁和生成都由Spring控制
- 降低了开发难度，需要什么就直接注入即可。


## SpringMVC、动态代理、反射、AOP 原理、事务隔离级别；
- 


# 六、中间件篇

## Dubbo 完整的一次调用链路介绍；
- dubbo注册中心服务注册发现的具体过程：
    - 服务提供者启动，向注册中心注册自己提供的服务
    - 消费者启动，向注册中心订阅自己需要的服务
    - 注册中心返回服务提供者的列表给消费者
    - 消费者从服务提供者列表中，按照软负载均衡算法，选择一台发起请求


## Dubbo 支持几种负载均衡策略？
- random随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。
- roundrobin轮询，按公约后的权重设置轮循比率，存在慢的提供者累积请求问题，
比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。
- leastactive最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。
             使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。
- consistenthash一致性hash，一致性Hash，相同参数的请求总是发到同一提供者。
                        当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。


## Dubbo Provider 服务提供者要控制执行并发请求上限，具体怎么做？
https://www.cnblogs.com/luozhiyun/p/10960593.html
- dubbo.provider.executes=10
- 控制并发请求数，表示每服务的每方法最大可并行执行请求数

# Dubbo 启动的时候支持几种配置方式？
- 1. XML 配置文件方式
- 2. properties 配置文件方式
    - 应用名 dubbo.application.name=dubbodemo-provider
    - 注册中心地址 dubbo.registry.address=zookeeper://localhost:2181
    - 调用协议地址
        - dubbo.protocol.name=dubbo
        - dubbo.protocol.port=28080
- 3. annotation 配置方式
    - com.alibaba.dubbo.config.annotation.Service 提供服务
    - com.alibaba.dubbo.config.annotation.Reference 引用服务
- 4. API 配置方式

# 了解几种消息中间件产品？各产品的优缺点介绍；
- 中间件的特性：解耦，异步操作业务-提高性能吞吐量，削峰限流
- RocketMQ：
- 应用场景
- RocketMQ应用到Cache，可以用在大量机器同步信息的场景
- 业务削峰，在大量交易涌入时，后端可能无法及时处理，所以MQ的大量消息堆积功能就可以发挥作用。
- 日志收集，RocketMQ的设计模型从Kafka衍生而来，kafka在日志收集系统中充当缓冲功能，随意RocketMQ也适用此场景
- 对可靠性要求很高的场景，尤其是电商里面的订单扣款，因为扣款要涉及到很多第三方支付。

- 优点
    顺序性，它支持顺序性，可以做到局部有序，在单线程内使用该生产者发送的消息按照发送的顺序到达服务器并存储，并按照相同顺序被消费，但前提是这些消息发往同一服务器的同一个分区
    实时性：采取长轮询+PULL消费消息，你可以自己决定如何在响应性和吞吐量之间做平衡，配合合理的参数设置来获得更高的响应时间，实时性不低于PUSH方式
    提供了丰富的拉取模式
    支持10亿级别的消息堆积，不会因为堆积导致性能下降
    高效的订阅者水平扩展机制

- 缺点
    消息重复问题，它不能保证不重复，只能保证正常情况下不重复
    不支持分布式事务
    消息过滤功能扩展比较单一


## 消息中间件如何保证消息的一致性和如何进行消息的重试机制？
- 消息一致性：
    - 消息发送一致性是指产生消息的业务动作与消息发送的一致，如果业务操作成功了，那么对应的消息一定要发送出去，否则就丢失消息。
    而另一方面，如果这个业务行为没有发生或者失败，那么就不应该把消息发出去。
    - 解决办法
        - 使用分布式事务实现消息一致性

◎ Spring Cloud 熔断机制介绍；

◎ Spring Cloud 对比下 Dubbo，什么场景下该使用 Spring Cloud？

# 七、数据库篇

## 锁机制介绍：行锁、表锁、排他锁、共享锁、共享锁；
- 行锁：只锁住需要使用到的行,Mysql中innodb引擎支持，只要是使用到了对应得索引就会使用行锁
    （包括 没有查到数据，或者查询的字段没加索引，都会使用表锁）
    - 排他锁：如果加排他锁可以使用select ...for update语句
        - 排他锁的申请前提 : 没有线程对该结果集中的任何行数据使用排他锁或共享锁，否则申请会阻塞
        - 排他锁又称为写锁，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，
        但是获取排他锁的事务是可以对数据行读取和修改。
    - 共享锁：加共享锁可以使用select ... lock in share mode语句
        - 共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改
- 表锁：锁住全表，相当于独占锁，只要没有命中索引都是表锁


## 乐观锁的业务场景及实现方式；
- 乐观锁：
    - 乐观锁方案 : 每次获取商品时，不对该商品加锁。在更新数据的时候需要比较程序中的库存量与数据库中的库存量是否相等，如果相等则进行更新，
反之程序重新获取库存量，再次进行比较，直到两个库存量的数值相等才进行数据更新。
    - 适合场景：乐观锁更适合读取频繁的场景。
    - 
    ```
  
        # 不加锁获取 id=1 的商品对象
      SELECT * FROM goods WHERE id=1;
      
      BEGIN;
      # 更新 stock 值，这里需要注意 where 条件 "stock=cur_stock"，只有程序中获取到的库存量与数据库中的库存量相等才执行更新
      UPDATE goods SET stock=stock-1 WHERE id=1 AND stock=cur_stock;
      COMMIT;
  
    ```

## 事务介绍，分布式事物的理解，常见的解决方案有哪些，什么事两阶段提交、三阶段提交；


## MySQL 记录 binlog 的方式主要包括三种模式？每种模式的优缺点是什么？
- Statement Level（sql模式 默认）：每一条会**修改数据的sql**都会记录到master的bin-log中。slave在复制的时候sql进程会解析成和原来master端执行过的相同的sql来再次执行
    - 优点：statement level下的优点首先就是解决了row level下的缺点，不需要记录每一行数据的变化，减少bin-log日志量，节约IO，提高性能，因为它只需要在Master上锁执行的语句的细节，以及执行语句的上下文的信息。
    - 缺点：由于只记录语句，所以，在statement level下 已经发现了有不少情况会造成MySQL的复制出现问题，主要是修改数据的时候使用了某些定的函数或者功能的时候会出现。 
- Row Level（行模式）：日志中会记录**每一行数据**被修改的形式，然后在slave端再对相同的数据进行修改
- Mixed （自动模式）：在Mixed模式下，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志格式，**也就是在Statement和Row之间选择一种**。
如果sql语句确实就是update或者delete等修改数据的语句，那么还是会记录所有行的变更。

## 分布式事务的原理 2 阶段提交，同步\异步\阻塞\非阻塞；

## 数据库事务隔离级别，MySQL 默认的隔离级别、Spring 如何实现事务、JDBC 如何实现事务、嵌套事务实现、分布式事务实现；
- 未提交 已提交 可重复读 串行化
- 默认是Repeatable
- Spring事务：

## SQL的整个解析、执行过程原理、SQL行转列；

八、Redis

## Redis 为什么这么快？redis 采用多线程会有哪些问题？
- Redis 为什么这么快:单线程，内存型，key-value类型结构 简单，操作快
- redis-benchmark来性能评估
- redis 采用多线程会有哪些问题：会出现数据不一致的情况，可以使用分布式锁来解决
    - set ex


## Redis 支持哪几种数据结构；
String ，set ，sorted set，list， hash，geo地理位置 经纬度的保存处理，布隆过滤器，机器学习 machine Learning，ES。 
Pub/Sub消息订阅与分发，Redis Stream消息队列

## Redis跳跃表的问题；
Skip list的性质
(1) 由很多层结构组成，level是通过一定的概率随机产生的。
(2) 每一层都是一个有序的链表，默认是升序
(3) 最底层(Level 1)的链表包含所有元素。
(4) 如果一个元素出现在Level i 的链表中，则它在Level i 之下的链表也都会出现。
(5) 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。


## Redis 单进程单线程的 Redis 如何能够高并发?
https://www.cnblogs.com/darknebula/p/10072658.html
- 事件驱动模型还有另外一个名字，而且更加出名的名字：io多路复用。
- IO多路复用：采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗）
- 为什么不采用多进程或多线程处理？
  - 多线程处理可能涉及到锁 
  - 多线程处理会涉及到线程切换而消耗CPU资源
  
- 单线程处理的缺点？
    - 无法发挥多核CPU性能，不过可以通过在**单机开多个Redis实例来完善**

## Redis 如何使用 Redis 实现分布式锁？
- setex ex 60 123
    - Redis Setex 命令为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值。
    - 借助于redis中的命令setnx(key, value)，key不存在就新增，存在就什么都不做。同时有多个客户端发送setnx命令，只有一个客户端可以成功，返回1（true）；其他的客户端返回0（false）。


## Redis分布式锁操作的原子性，Redis 内部是如何实现的？
- 

九、其他

◎ 看过哪些源代码？然后会根据你说的源码问一些细节的问题？（这里主要考察面试者是否对技术有钻研的精神，还是只停留在表面，还是背了几道面经，这个对于很多有强迫症的面试官，如果你连源码都没看过，基本上是会 pass 掉的，比如我也是这样的！）

◎ 项目中遇到了哪些比较有挑战性的问题，是如何解决的；（这个很有争议，一方面是你连一个复杂的问题都解决不了，要你过来干什么，还有就是，我的能力牛逼啊，但是公司没有业务场景让我展示啊！这个就看你遇到的面试官了，祝你好运！）





到此为止，大致把一些面试官高频的面试题整理了一下，希望对大家有所帮助！

整理自：Java 后端技术

作者：徐刘根
公众号：Java 之间

精选评论

暂无新的评论
相关公司

 


75
