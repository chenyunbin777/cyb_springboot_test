# 链路追踪
## 数据收集
- 1 服务追踪的实现思路是通过某些手段给目标应用注入追踪探针（Probe），针对 Java 应用一般就是通过 Java Agent 注入的。探针在结构上可视为一个寄生在目标服务身上的小型微服务系统，
它一般会有自己专用的**服务注册、心跳检测**等功能，有专门的数据收集协议，把从目标系统中监控得到的服务调用信息，**通过另一次独立的 HTTP 或者 RPC 请求发送给追踪系统**

- 2 因此，基于服务的追踪会比基于日志的追踪消耗更多的资源，也有更强的侵入性，换来的收益是追踪的精确性与稳定性都有所保证，不必再依靠日志归集来传输追踪数据。

- 总结：服务追踪系统也是一个小的微服务集群，可以接收到不同服务发来的http or tcp的请求，从而来记录对应的追踪日志； 

- 轻量化服务追踪方案可以选择sky walking



## 追踪规范化
- 市面上所有的追踪服务基本上都是根据 Dapper 的论文为原型发展出来的，功能上并没有太本质的差距，却又受制于实现细节，彼此互斥，很难搭配工作。
这种局面只能怪当初 Google 发表的 Dapper 只是论文而不是有约束力的规范标准，只提供了思路，并没有规定细节，譬如该怎样进行**埋点、Span 上下文**具体该有什么数据结构，
怎样设计追踪系统与探针或者界面端的 API 接口，等等，都没有权威的规定。

- OpenTracing 和 OpenCensus：统一服务实现的协议与规范

- OpenTelemetry：它的目标是统一追踪、度量和日志三大领域

## 追踪服务
- Zipkin、Jaeger、SkyWalking 

## 问题
- 1 "探针" 具体是怎么实现的？
    - 通过另一次独立的 HTTP 或者 RPC 请求发送给追踪系统
    - 追踪系统接收需要监测数据，然后收集分析
    - 通过心跳检测对应服务是否异常，可以做出异常监控 进行异常推送到指定的人员或者通知。