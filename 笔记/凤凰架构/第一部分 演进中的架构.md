# 服务架构演进史
- 架构并不是被发明出来的，而是持续演进的结果，本章我们暂且放下代码与技术，借讨论历史之名，来梳理软件架构发展历程中出现过的名词术语，
以全局的视角，从这些概念的起源去分析它们是什么、它们取代了什么，以及它们为什么能够在竞争中取得成功，为什么变得不可或缺，
又或者它们为什么会失败，在斗争中被淘汰，逐渐湮灭于历史的烟尘当中。


## 带着问题去看
- 无服务是什么？


## 原始分布式时代
- 惠普公司（及后来被惠普收购的 Apollo）提出的 **网络运算架构（Network Computing Architecture，NCA）** 是未来远程服务调用的雏形
- 为了避免UNIX 系统的版本战争在分布式领域中重演，负责制定 UNIX 系统技术标准的“开放软件基金会”（Open Software Foundation，OSF，也即后来的“国际开放标准组织”）
邀请了当时业界主流的计算机厂商一起参与，共同制订了名为 **“分布式运算环境”（Distributed Computing Environment，DCE）** 的分布式技术体系。
- DCE 包含一套相对完整的分布式服务组件规范与参考实现，譬如源自 NCA 的远程服务调用规范（Remote Procedure Call，RPC），当时被称为DCE/RPC，
它与后来 Sun 公司向互联网工程任务组（Internet Engineering Task Force，IETF）提交的基于通用 TCP/IP 协议的远程服务标准ONC RPC被认为是现代 RPC 的共同鼻祖
- DFS ，Distributed File System：分布式文件系统

- “调用远程方法”与“调用本地方法”尽管只是两字之差，但若要同时兼顾简单、透明、性能、正确、一致等特点的话，两者的复杂度就完全不可同日而语了。
且不说远程方法不能再依靠本地方法那些以内联为代表的传统编译优化来提升速度，光是“远程”二字带来的网络环境下的新问题，譬如，
远程的服务在哪里（服务发现），
有多少个（负载均衡），
网络出现分区、超时或者服务出错了怎么办（熔断、隔离、降级），
方法的参数与返回结果如何表示（序列化协议），
信息如何传输（传输协议），
服务权限如何管理（认证、授权），
如何保证通信安全（网络安全层），
如何令调用不同机器的服务返回相同的结果（分布式数据一致性）等一系列问题，
全部都需要设计者耗费大量心思。

- 原始分布式时代提出的构建“符合 UNIX 的设计哲学的”“如同本地调用一般简单透明的”分布式系统这个目标，是软件开发者对分布式系统最初的美好愿景，
迫于现实，它会在一定时期内被妥协、被舍弃，换句话说，分布式将会经过一段越来越复杂的发展进程。但是，到了三十多年以后的将来（即 2016 年服务网格重新提出透明通信的时候），
随着分布式架构的逐渐成熟完善，取代单体成为大型软件的主流架构风格以后，这个美好的愿景终将还是会重新被开发者拾起。



# 单体系统时代
- 优点：
    - 实现简单、易维护、适合小型扩张速度慢的项目
    - 在负载均衡器之后同时部署若干个相同的单体系统副本，以达到分摊流量压力的效果，也是非常常见的需求。
- 缺点：
    - 在“拆分”这方面，单体系统的真正缺陷不在如何拆分，而在拆分之后的隔离与自治能力上的欠缺。
    - 所有代码都在使用同一个进程空间，不能隔离，无法单独停止、更新、升级某一部分代码
    - 程序升级、修改缺陷往往需要制定专门的停机更新计划，做灰度发布、A/B 测试也相对更复杂。
        
- 对于不同的企业级应用，要根据业务的需求定制具体的技术实现方案，不要一味的追求"时髦" 而忘记的业务需求。
    - 要考虑服务的膨胀速度、系统规模、部署成本、技术升级的迁移成本等。
    - 如 小卖部与超市
    - 

## 总结
- 微服务的优点：
    - 定义好最优的边界，划分不同代码的职责与任务，将其分解成多个高内聚、低耦合的多个服务，服务之间通过PRC，MQ来进行通信；
    - 在项目发布的时候无需整体发布，只需要发布修改的微服务即可，降低出错概率。
- 微服务的缺点：
    - 一个大型的企业级应用可能会拆分出几十甚至上百个应用，可能会有不同的语言实现，后续人员难以管理与维护；
    - 服务拆分过于"微服务"导致各个功能模块可能分散在不同的服务中，调用链路错综复杂很容易出现问题。
    - 服务器的开销，要考虑经济成本、维护成本。
- 所以说在做微服务拆分的时候最需要注意的就是 "微" 的这个度，过大 过小的拆分都可能造成不同的问题。要考虑服务之间的通信方式是否简单、可靠，不同语言服务交互的方式是否便捷。

- 正是随着软件架构演进，构筑可靠系统从“追求尽量不出错”，到正视“出错是必然”的观念转变，才是微服务架构得以挑战并逐步开始取代运作了数十年的单体架构的底气所在。
- **为了允许程序出错，为了获得隔离、自治的能力**，为了可以技术异构等目标，是继为了性能与算力之后，让程序再次选择分布式的理由。




# 面向服务的架构 SOA时代 Service Oriented Architecture，SOA
- 烟囱式架构（Information Silo Architecture）：信息烟囱又名信息孤岛（Information Island），使用这种架构的系统也被称为孤岛式信息系统或者烟囱式信息系统。
指的是一种完全不与其他相关信息系统进行互操作或者协调工作的设计模式。

- 微内核架构（Microkernel Architecture）：微内核架构也被称为插件式架构（Plug-in Architecture）。
- 事件驱动架构（Event-Driven Architecture）：为了能让子系统互相通信，一种可行的方案是在子系统之间建立一套事件队列管道（Event Queues），来自系统外部的消息将以事件的形式发送至管道中，
各个子系统从管道里获取自己感兴趣、能够处理的事件消息，也可以为事件新增或者修改其中的附加信息，甚至可以自己发布一些新的事件到管道队列中去，如此，每一个消息的处理者都是独立的，高度解耦的，
但又能与其他处理者（如果存在该消息处理者的话）通过事件管道进行互动。
    - 与消息队列MQ类似
    
- SOA：SOA 本身还是属抽象概念，而不是特指某一种具体的技术，但它比单体架构和前面所列举的三种架构模式的操作性要更强
    - SOAP：远程服务调用协议，Service Oriented Architecture Protocol
    - SOA常见的一些思想：服务之间的松散耦合、注册、发现、治理，隔离、编排
    - SOA 在 21 世纪最初的十年里曾经盛行一时，有 IBM 等一众行业巨头厂商为其呐喊冲锋，吸引了不少软件开发商、尤其是企业级软件的开发商的跟随，最终却还是偃旗息鼓，沉寂了下去。
    - SOA 最终没有获得成功的致命伤与当年的EJB如出一辙，尽管有 Sun Microsystems 和 IBM 等一众巨头在背后力挺，EJB 仍然败于以 Spring、Hibernate 为代表的“草根框架”，可见一旦脱离人民群众，终究会淹没在群众的海洋之中，连信息技术也不曾例外过。
 
- 服务发展的目的：让开发人员不必关心服务是远程还是本地，都能够透明地调用服务或者访问资源。



# 微服务时代
- 微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。
服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。
## 微服务的九个核心的业务与技术特征
- 1 围绕业务能力构建：有怎么样的结构、规模、能力的团队，就会产生出对应结构、规模、能力的产品。这个结论不是某个团队、某个公司遇到的巧合，而是**必然演化的结果**
本应该归属同一个产品内的功能被划分在不同团队中，必然会产生大量的跨团队沟通协作，**跨越团队边界无论在管理、沟通、工作安排上都有更高昂的成本**，
高效的团队自然会针对其进行改进，当团队、**产品磨合**调节稳定之后，团队与产品就会拥有一致的结构。
    - 关键词：必然演化的结果、团队沟通协作成本、产品磨合、功能划分。  锻炼造句能力。
    - **康威定律**：是马尔文康威1967提出的：“设计系统的架构受制于产生这些设计的组织的沟通结构。”通俗的来讲：产品必然是其（人员）组织沟通结构的缩影。

- 2 分散治理：
    - 我的理解：分而治之，也就是一口无法吃成个胖子，要一口一口的吃，慢慢消化。 将一个大的功能，将其细化成多个可以拆分的小服务，从而可以分开管理、维护，也就是不用牵一发而动全身。
    局部的修改、发布并不会影响大局。
    
- 3 通过服务来实现独立自治的组件（Componentization via Services）
    - 一个服务都是每一个可以运行在任何位置的所谓的 "组件"，拥有**隔离与自治能力**，但是相对的调用代价要高很多。要抛弃SOA那种插件的思想，转换成以 "服务" 为单位的思想。
    - **关键词：隔离、自治能力**
    
- 4 产品化思维（Products not Projects）。
    - 避免把软件研发视作要去完成某种功能，而是视作一种持续改进、提升的过程。
    - 在微服务下，要求开发团队中每个人都具有**产品化思维**，关心整个产品的全部方面是具有可行性的。
    - 不应该把运维只看作运维团队的事，把开发只看作开发团队的事，团队应该为软件产品的整个**生命周期**负责，
    开发者不仅应该知道软件如何开发，还应该知道它如何运作，用户如何反馈，乃至售后支持工作是怎样进行的。
    - **关键词：产品化思维、产品生命周期、持续改进、提升**
  
- 5 数据去中心化（Decentralized Data Management）。
    - 数据分散到多个不同的存储空间中，如 分库 分表。在单体应用时都是所有的数据存储在同一个存储空间，也就是同一个中心系统中，并不需要考虑分布式事务、数据一致性。分布式锁等一系列问题。我们将数据分类存储在不同的介质中
    方便我们存取不同的数据，不同存储中的数据即可以隔离，也可以有联系，灵活多变
    - 在分布式中很多时候无法使用传统的事务处理，这是值得复出的代价。
    
- 6 强终端弱管道（Smart Endpoint and Dumb Pipe）。
    - RESTful 风格的通信在微服务中会是更加合适的选择
    
- 7 容错性设计（Design for Failure）。、
    - 不再虚幻地追求服务永远稳定，而是接受服务总会出错的现实，要求在微服务的设计中，有自动的机制对其依赖的服务能够进行快速故障检测，在持续出错的时候进行隔离，在服务恢复的时候重新联通。
    - **关键词：故障检测、隔离、重新连通、恢复、**
    
    
- 8 演进式设计（Evolutionary Design）。
    - 容错性设计承认服务会出错，演进式设计则是承认服务会被报废淘汰。一个设计良好的服务，应该是能够报废的，而不是期望得到长存永生。
    
    
- 9 基础设施自动化（Infrastructure Automation）。
    - 基础设施自动化，如 CI/CD 的长足发展，显著减少了构建、发布、运维工作的复杂性。由于微服务下运维的对象比起单体架构要有数量级的增长，使用微服务的团队更加依赖于基础设施的自动化，
    人工是很难支撑成百上千乃至成千上万级别的服务的。
    - 关键词：自动化检测、监控、自动化恢复、通知

- 微服务时代遇到的一些问题
    - 服务的注册发现、跟踪治理、负载均衡、故障隔离、认证授权、伸缩扩展、传输通信、事务处理
    - 远程调用可选择方案：RMI（Sun/Oracle）、Thrift（Facebook）、Dubbo（阿里巴巴）、gRPC（Google）、Motan2（新浪）、Finagle（Twitter）、brpc（百度）、Arvo（Hadoop）、JSON-RPC、REST
    - 服务发现问题，可以选择的就有：Eureka（Netflix）、Consul（HashiCorp）、Nacos（阿里巴巴）、ZooKeeper（Apache）、Etcd（CoreOS）、CoreDNS（CNCF），等等。其他领域的情况也是与此类似，总之，完全是八仙过海，各显神通的局面。
    - 微服务丢掉了 SOA 的强标准，换来了自由。自由的代价是工程师需根据业务情况选择适合的技术，过程中会犯错。微服务带来自由，也带来迷茫。
        -微服务时代充满着自由的气息，微服务时代充斥着迷茫的选择。
    - **关键词：决策权衡、架构能力、取舍、自由的气息、迷茫的选择**
    


# 后微服务时代（Cloud Native）
- 从软件层面独力应对微服务架构问题，发展到软、硬一体，合力应对架构问题的时代，此即为“后微服务时代”。
- 也就是进入了容器化的时代，k8s+docker
- 边车代理（Sidecar Proxy）：所谓的“边车”是一种带垮斗的三轮摩托
    - 这个场景里指的具体含义是由系统自动在服务容器（通常是指 Kubernetes 的 Pod）中注入一个通信代理服务器，相当于那个挎斗，以类似网络安全里中间人攻击的方式进行流量劫持，
    在应用毫无感知的情况下，悄然接管应用所有对外通信。这个代理除了实现正常的服务间通信外（称为数据平面通信），还接收来自控制器的指令（称为控制平面通信），根据控制平面中的配置，
    对数据平面通信的内容进行分析处理，以实现熔断、认证、度量、监控、负载均衡等各种附加功能。这样便实现了既不需要在应用层面加入额外的处理代码，也提供了几乎不亚于程序代码的精细管理能力。
    
    - 关键词：无感知、熔断、认证、度量、监控、负载均衡、精细管理能力


# 无服务架构、无服务器架构（Serverless）
- 如果说微服务架构是分布式系统这条路的极致，那无服务架构，也许就是“不分布式”的云端系统这条路的起点。
- 对软件研发而言，不去做分布式无疑才是最简单的，如果**单台服务器的性能可以是无限的**，那架构演进的结果肯定会与今天有很大的差别，分布式也好，容器化也好，微服务也好，恐怕都未必会如期出现，
最起码不必一定是像今天这个样子。
- 将无服务作为技术层面的架构，将微服务视为应用层面的架构，把它们组合起来使用是完全合理可行的。以后，无论是通过物理机、虚拟机、容器，抑或是无服务云函数，都会是微服务实现方案的候选项之一。


- **无服务架构** 它只涉及两块内容：后端设施（Backend）和函数（Function）。
    - 1 后端设施是指数据库、消息队列、日志、存储，等等这一类用于支撑业务逻辑运行，
    但本身无业务含义的技术组件，这些后端设施都运行在云中，无服务中称其为“后端即服务”（Backend as a Service，BaaS）。
    - 2 函数是指业务逻辑代码，这里函数的概念与粒度，都已经很接近于程序编码角度的函数了，其区别是无服务中的函数运行在云端，不必考虑算力问题，
    不必考虑容量规划（从技术角度可以不考虑，从计费的角度你的钱包够不够用还是要掂量一下的），无服务中称其为“函数即服务”（Function as a Service，FaaS）。


- 云服务到底是什么？如何实现？
    - 1 云服务指通过网络以按需、易扩展的方式获得所需服务，可以动态的将资源切换到需要的应用上。

    - 微服务：需关注弹性伸缩策略、服务间通信、架构、日志、告警等；
    - 无服务：无需关注运行时。函数间是平等关系。
    - （当前）无服务适合场景：短链接、无状态、适合事件驱动的交互形式，比如 Web 网站、定时任务、小程序/App 后台等。
不适合逻辑复杂、依赖服务端状态、响应速度要求较高、长链接等应用，比如网络游戏、直播等。

- 关键词：无服务器架构、容错能力、技术异构、职责划分、相对意义的无限性能、云计算：算力问题、容量规划

- 个人总结：无服务感觉就像是开发人员只需要关注代码细节、业务细节，而不需要关注如何运行部署。异常处理、监控、服务熔断、负载均衡、动态扩容、缩容，
还有各种服务的基础设施如：DB实现、MQ实现、缓存实现等。趋近于一种 **业务实现** 与 **程序运维** 之间的隔离
