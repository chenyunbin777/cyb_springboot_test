# 一 三次握手协议
指的是在发送数据的准备阶段，服务器端和客户端之间需要进行三次交互：
（1）第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
（2）第二次握手：服务器收到syn包，必须确认客户的syn（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
（3）第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。连接建立后，客户端和服务器就可以开始进行数据传输了。

客户端：send 状态包 j ，等待服务器确认
服务端：send 状态包k，与j+1（说名服务端收到了客户端的消息）
客户端：send 状态包j+1，k+1, 说明客户端确认了服务端收到了消息，然后返回。此时client与server建立了连接。

# 二 四次挥手 拜拜，断开连接：中断连接端能够是Client端，也能够是Server端
- 1 假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，可是假设你还有数据没有发送完毕，
则不必急着关闭Socket，能够继续发送数据。
- 2 所以你先发送ACK，"告诉Client端，你的请求我收到了，可是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，
继续等待Server端的FIN报文。
- 3 当Server端确定数据已发送完毕，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。
- 4 Client端收到FIN报文后，"就知道能够关闭连接了，可是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入**TIME_WAIT**状态，假设Server端没有收到ACK则能够重传。
“，Server端收到ACK后，"就知道能够断开连接了"。Client端等待了2MSL后依旧没有收到回复，则证明Server端已正常关闭，那好，我Client端也能够关闭连接了。Ok，TCP连接就这样关闭了！


总结：
1 客户端发送关闭消息给服务端
2 服务端此时有可能还有消息需要发送只能返回一个确认收到 客户端关闭连接的请求
3 当服务端传输完数据之后，最终会发送一个服务端关闭连接的请求
4 此时Client端收到FIN报文后，"就知道能够关闭连接了，可是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入**TIME_WAIT**状态，在2ML之后
依旧没有收到回复，则证明Server端已正常关闭，那好，我Client端也能够关闭连接了。

2MSL：MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

FTP(File Transfer Protocol 文件传输协议)
DNS（Domain Name System 域名系统）

传输层安全性协议（英语：Transport Layer Security，缩写作TLS），及其前身安全套接层（Secure Sockets Layer，缩写作SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。

HTTP是不保存状态的协议，在http/1.1中所有链接默认是持久链接
http的缺点：1）通信使用明文（不加密），内容坑内会被窃听
2）不验证通信方的身份，因此有可能遭遇伪装
3)  无法证明报文的完整性，所有有可能已遭串改
HTTP+加密+认证+完整性保护 = HTTPS
HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已


# TCP 滑动窗口
- TCP 流量控制，主要使用滑动窗口协议，滑动窗口是接受数据端使用的窗口大小，用来告诉发送端接收端的缓存大小，
以此可以控制发送端发送数据的大小，从而达到流量控制的目的。这个窗口大小就是我们一次传输几个数据。对所有数据帧按顺序赋予编号，
发送方在发送过程中始终保持着一个发送窗口，只有落在发送窗口内的帧才允许被发送；同时接收方也维持着一个接收窗口，
只有落在接收窗口内的帧才允许接收。

# TCP 粘包和拆包
- 概念
    - 粘包：发送数据小于发送缓冲区的大小，tcp会将多个数据放在一起发送
    - 拆包：要发送的数据大于 **TCP发送缓冲区**剩余空间大小，将会发生拆包。

- 解决方式
    -1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
    -2、发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
    -3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。
- netty解决方案
    - FixedLengthFrameDecoder：固定长度的粘包和拆包，该解码一器会每次读取固定长度的消息
    - DelimiterBasedFrameDecoder（添加特殊分隔符报文来分包）   
    
