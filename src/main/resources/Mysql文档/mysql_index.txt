一 聚簇索引和非聚簇索引
https://my.oschina.net/xiaoyoung/blog/3046779
数据结构：B+树🌲
总结：InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构
1 聚簇索引
（1）聚簇索引：就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为"数据页"。
这个特性决定了索引组织表中数据也是索引的一部分；
（2）一般建表会用一个"自增主键"做聚簇索引，没有的话MySQL会默认创建选择一个唯一且非空的索引替代，如果没有这样的索引，InnoDB会隐式定义一个主键（类似oracle中的RowId）来作为聚簇索引。
    一个表仅有一个聚簇索引，一般都是主键索引。
（3）辅助索引：我们日常工作中，根据实际情况自行添加的索引都是"辅助索引"（非主键索引），也称为二级索引，辅助索引就是一个为了需找主键索引的二级索引，现在找到"主键索引值"再通过主键索引找数据；
    辅助索引检索数据的过程：现在辅助索引中检索到对应的聚簇索引的值，再根据该主键值检索聚簇索引而找到对应的B+ Tree的叶子节点，也就找到了对应的行数据。
    例如：user表 id主键，name建立普通的索引
    select * from user where name = 'cyb'
    我们先通过辅助索引name来在辅助索引的B+tree中检索，找到对应的行的主键值，
    然后在跟进主键值去聚蔟索引的B+Tree中检索找到对应的叶子节点，也就找到了对应的Mysql的数据行的值。


（4）支持行锁
（5）select count(*) from table 会全部扫描，不会缓存

2 使用聚簇索引的优势：
每次使用辅助索引检索都要经过两次B+树查找，看上去聚簇索引的效率明显要低于非聚簇索引，这不是多此一举吗？聚簇索引的优势在哪？
（1）由于行数据和聚簇索引的叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中（缓存器），
再次访问时，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，
如果按照主键Id来组织数据，获得数据更快。

（2）辅助索引的叶子节点，存储主键值，而不是数据的存放地址。好处是当行数据放生变化时，索引树的节点也需要分裂变化；或者是我们需要查找的数据，
在上一次IO读写的缓存中没有，需要发生一次新的IO操作时，可以避免对辅助索引的维护工作，只需要维护聚簇索引树就好了。
另一个好处是，因为辅助索引存放的是主键值，减少了辅助索引占用的存储空间大小。

注：我们知道一次io读写，可以获取到16K大小的资源，我们称之为读取到的数据区域为Page。
而我们的B树，B+树的索引结构，叶子节点上存放好多个关键字（索引值）和对应的数据，
都会在一次IO操作中被读取到缓存中，所以在访问同一个页中的不同记录时，会在内存里操作，
而不用再次进行IO操作了。除非发生了页的分裂，即要查询的行数据不在上次IO操作的缓存里，才会触发新的IO操作。
（ 发生页分裂的话，b+tree会重组，需要重新IO来查询）

（3）因为MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，
于是开始不停的寻道不停的旋转。聚簇索引则只需一次I/O。（强烈的对比）

（4）不过，如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。

3 innodb和myisam的区别

1）InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。
9）InnoDB支持行锁，而MyISAM支持表级锁
InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。
命中索引：包括 没有查到数据，或者查询的字段没加索引
如：user表 id主键，name建立普通的索引，age 没有索引
    select * from user where name = 'cyb' 如果没有查到，表锁；如果查到了，行锁
    select * from user where age = 18 表锁，因为age没有加索引

2）MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用
3）InnoDB支持外键，MyISAM不支持
4）InnoDB select count(*) from table 会全部扫描，不会缓存；而MyISAM用一个变量保存了整个表的行数
5）InnoDB不支持FULLTEXT类型的索引
6）InnoDB中不保存表的行数，如select count() from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时MyISAM也需要扫描整个表
7）对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引
8）清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表


二 索引优化
1 索引覆盖：
是指 如果查询的列恰好是索引的一部分，那么查询只需要在索引文件上进行，不需要回行到磁盘在找数据。
如果和整个表的数据差不多，mysql则认为全表扫描代价更小
是查询的数据多了之后，mysql认为还是索引查询更快，所以用了索引。
总结：mysql会自动选择比较快的查询方式来进行查询。

2 最左前缀原则
在 MySQL 中，可以指定多个列为索引，即联合索引。
比如 index(name，age) ，最左前缀原则是指查询时精确匹配到从最左边开始的一列或几列（name；name&age），就可以命中索引。
如果所有列都用到了，顺序不同，查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。
总结：mysql会对联合索引进行优化

3 修复空间碎片
optimize table 表名;

4 什么样的sql不走索引
（1）如果条件中有or，即使其中有条件带索引也不会使用。
（2）例如where id *1 , 使用 + - * /
（3）使用函数：'2020-12-03' = DATE_FORMAT(date_create,'%Y-%m-%d')
（4）字符串与数字比较不使用索引;

5 索引的弊端
不要盲目的创建索引，只为查询操作频繁的列创建索引，创建索引会使查询操作变得更加快速，但是会降低增加、删除、更新操作的速度，因为执行这些操作的同时会对索引文件进行重新排序或更新。
但是，在互联网应用中，查询的语句远远大于DML的语句，甚至可以占到80%~90%，所以也不要太在意，只是在大数据导入时，可以先删除索引，再批量插入数据，最后再添加索引。

6 limit 优化
https://www.jb51.net/article/31868.htm
在mysql中limit可以实现快速分页，但是如果数据到了几百万时我们的limit必须优化才能有效的合理的实现分页了，否则可能卡死你的服务器哦。PERCONA PERFORMANCE CONFERENCE 2009上，来自雅虎的几位工程师带来了一篇”EfficientPagination Using MySQL”的报告: limit10000,20的意思扫描满足条件的10020行，扔掉前面的10000行，返回最后的20行，问题就在这里。
(1)日常分页SQL语句
select id,name,content from users order by id asc limit 100000,20
扫描100020行
(2)如果记录了上次的最大ID
select id,name,content from users where id>100073 order by id asc limit 20
扫描20行。
(3)如果id是连续的：
SELECT * FROM table WHERE id >= (SELECT id FROM table LIMIT 1000000, 1) LIMIT 10;
(4)终极优化:如果需要查询 id 不是连续的一段，最佳的方法就是先找出 id ，然后用 in 查询
1 先找出id，通过建立search(vtype,id) 这样的索引
select id from collect where vtype=1 limit 90000,10; 非常快！0.04秒完成！
2 然后在 SELECT * FROM table WHERE id IN(10000, 100000, 1000000...);


